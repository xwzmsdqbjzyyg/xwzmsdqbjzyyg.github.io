<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一天进步一点</title>
  <subtitle>一天进步一点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xwzmsdqbjzyyg.github.io/"/>
  <updated>2016-10-24T06:12:29.833Z</updated>
  <id>http://xwzmsdqbjzyyg.github.io/</id>
  
  <author>
    <name>陈长生</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《许三观卖血记》片段</title>
    <link href="http://xwzmsdqbjzyyg.github.io/2016/10/24/xsdzcr/"/>
    <id>http://xwzmsdqbjzyyg.github.io/2016/10/24/xsdzcr/</id>
    <published>2016-10-24T06:02:08.000Z</published>
    <updated>2016-10-24T06:12:29.833Z</updated>
    
    <content type="html">&lt;p&gt;这天晚上，一家人躺在床上时，许三观对儿子们说：&lt;/p&gt;
&lt;p&gt;“我知道你们心里最想的是什么。就是吃，你们想吃米饭，想吃用油炒出来的菜，想吃鱼啊肉啊的。今天我过生日，你们都跟着享福了，连糖都吃到了，可我知道你们心里还想吃，还想吃什么。看在我过生日的份上，今天我就辛苦一下，我用嘴给你们每人炒，你们就用耳朵听着吃了，你们别用嘴，用嘴连个屁都吃不到，都把耳朵竖起来，我马上就要炒菜了。想吃什么，你们自己点。一个一个来，先从三乐开始。三乐，你想吃什么？”&lt;/p&gt;
&lt;p&gt;三乐轻声说：“我不想再喝粥了，我想吃米饭。”&lt;/p&gt;
&lt;p&gt;“米饭有的是，”许三观说，“米饭不限制，想吃多少就有多少、我问的是你想吃什么菜？”&lt;/p&gt;
&lt;p&gt;三乐说：“我想吃肉。”&lt;/p&gt;
&lt;p&gt;“三乐想吃肉，”许三观说，“我就给三乐做一个红烧肉。肉，有肥有瘦，红烧肉的话，最好是肥瘦各一半，而且还要带上肉皮，我先把肉切成一片一片的。有手指那么粗，半个手掌那么大，我给三乐切三片……”&lt;/p&gt;
&lt;p&gt;三乐说：“爹，给我切四片肉。”&lt;/p&gt;
&lt;p&gt;“我给三乐切四片肉……”&lt;/p&gt;
&lt;p&gt;三乐又说：“爹；给我切五片肉。”&lt;/p&gt;
&lt;p&gt;许三观说：“你最多只能吃四片，你这么小一个人，五片肉会把你撑死的。我先把四片肉放到水里煮一会，煮熟就行，不能煮老了，煮熟后拿起来晾干，晾干以后放到油锅里一炸，再放上酱油，放上一点五香，放上一点黄酒，再放上水，就用文火慢馒地炖，炖上两个小时，水差不多炖干时，红烧肉就做成了……”&lt;/p&gt;
&lt;p&gt;许三观听到了吞口水的声音。“揭开锅盖，一股肉香是扑鼻而来，拿起筷子，夹一片放到嘴里一咬……”&lt;/p&gt;
&lt;p&gt;许三观听到吞口水的声音越来越响。“是三乐一个人在吞口水吗？我听声音这么响，一乐和二乐也在吞口水吧？许玉兰你也吞上口水了，你们听着，这道菜是专给三乐做的，只准三乐一个人吞口水，你们要是吞上口水，就是说你们在抢三乐的红烧肉吃，你们的菜在后面，先让三乐吃得心里踏实了，我再给你们做。三乐，你把耳朵竖直了……夹一片放到嘴里一咬，味道是，肥的是肥而不腻，瘦的是丝丝饱满。我为什么要用文火炖肉？就是为了让味道全部炖进去。三乐的这四片红烧肉是……三乐，你可以馒馒品尝了。接下去是二乐，二乐想吃什么？”&lt;/p&gt;
&lt;p&gt;二乐说：“我也要红烧肉，我要吃五片。”&lt;/p&gt;
&lt;p&gt;“好，我现在给二乐切上五片肉，肥瘦各一半，放到水里一煮，煮熟了拿出来晾干，再放到……”&lt;/p&gt;
&lt;p&gt;二乐说：“爹，一乐和三乐在吞口水。”&lt;/p&gt;
&lt;p&gt;“一乐，”许三观训斥道，“还没轮到你吞口水。”&lt;/p&gt;
&lt;p&gt;然后他继续说：“二乐是五片肉，放到油锅里一炸，再放上酱油，放上五香……”&lt;/p&gt;
&lt;p&gt;二乐说：“爹，三乐还在吞口水。”&lt;/p&gt;
&lt;p&gt;许三观说：“三乐吞口水，吃的是他自己的肉，不是你的肉，你的肉还没有做成呢……”&lt;/p&gt;
&lt;p&gt;许三观给二乐做完红烧肉以后，去问一乐：&lt;/p&gt;
&lt;p&gt;“一乐想吃什么？”&lt;/p&gt;
&lt;p&gt;一乐说：“红烧肉。”&lt;/p&gt;
&lt;p&gt;许三观有点不高兴了，他说：&lt;/p&gt;
&lt;p&gt;“三个小崽子都吃红烧肉，为什么不早说？早说的话，我就一起给你们做了……我给一乐切了五片肉……”&lt;/p&gt;
&lt;p&gt;一乐说：“我要六片肉。”&lt;/p&gt;
&lt;p&gt;“我给一乐切了六片肉，肥瘦各一半……”&lt;/p&gt;
&lt;p&gt;一乐说：“我不要瘦的，我全要肥肉。”&lt;/p&gt;
&lt;p&gt;许三观说：“肥瘦各一半才好吃。”&lt;/p&gt;
&lt;p&gt;一乐说：“我想吃肥肉，我想吃的肉里面要没有一点是瘦的。”&lt;/p&gt;
&lt;p&gt;二乐和三乐这时也叫道：“我们也想吃肥肉。”&lt;/p&gt;
&lt;p&gt;许三观给一乐做完了全肥的红烧肉以后，给许玉兰做了一条清炖鲫鱼。他在鱼肚子里面放上几片火腿，几片生姜，几片香菇，在鱼身上抹上一层盐，浇上一些黄酒，撒上一些葱花，然后炖了一个小时，从锅里取出来时是清香四溢……&lt;/p&gt;
&lt;p&gt;许三观绘声绘色做出来的清炖鲫鱼，使屋子里响起一片吞口水的声音，许三观就训斥儿子们：&lt;br&gt;“这是给你们妈做的鱼，不是给你们做的，你们吞什么口水？你们吃了那么多的肉，该给我睡觉了。”&lt;/p&gt;
&lt;p&gt;最后，许三观给自己做一道菜、他做的是爆炒猪肝，他说：&lt;/p&gt;
&lt;p&gt;“猪肝先是切成片，很小的片，然后放到一只碗里，放上一些盐，放上生粉，生粉让猪肝鲜嫩，再放上半盅黄酒，黄酒让猪肝有酒香，再放上切好的葱丝，等锅里的油一冒烟，把猪肝倒进油锅，炒一下，炒两下，三下……”&lt;/p&gt;
&lt;p&gt;“炒四下……炒五下……炒六下。”&lt;/p&gt;
&lt;p&gt;一乐，二乐，三乐接着许三观的话，一人跟着炒了一下，许三观立刻制止他们：&lt;/p&gt;
&lt;p&gt;“不，只能炒三下，炒到第四下就老了，第五下就硬了，第六下那就咬不动了，三下以后赶紧把猪肝倒出来。这时候不忙吃，先给自己斟上二两黄酒，先喝一口黄酒，黄酒从喉咙里下去时热乎乎的，就像是用热毛巾洗脸一样，黄酒先把肠子洗干净了，然后再拿起一双筷子，夹一片猪肝放进嘴里……这可是神仙过的日子……”&lt;/p&gt;
&lt;p&gt;屋子里吞口水的声音这时是又响成一片，许三观说：&lt;/p&gt;
&lt;p&gt;“这爆炒猪肝是我的菜，一乐，二乐，三乐，还有你许玉兰，你们都在吞口水，你们都在抢我的菜吃。”&lt;/p&gt;
&lt;p&gt;说着许三观高兴地哈哈大笑起来，他说：&lt;/p&gt;
&lt;p&gt;“今天我过生日，大家都来尝尝我的爆炒猪肝吧。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这天晚上，一家人躺在床上时，许三观对儿子们说：&lt;/p&gt;
&lt;p&gt;“我知道你们心里最想的是什么。就是吃，你们想吃米饭，想吃用油炒出来的菜，想吃鱼啊肉啊的。今天我过生日，你们都跟着享福了，连糖都吃到了，可我知道你们心里还想吃，还想吃什么。看在我过生日的份上，今天我就辛苦一下，我用
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>心魔</title>
    <link href="http://xwzmsdqbjzyyg.github.io/2016/08/18/xinmo/"/>
    <id>http://xwzmsdqbjzyyg.github.io/2016/08/18/xinmo/</id>
    <published>2016-08-18T02:15:49.000Z</published>
    <updated>2016-08-18T02:17:55.161Z</updated>
    
    <content type="html">&lt;p&gt;我靠打猎谋生，运气好能猎到鹿或野猪等大野物，十天半月不愁吃喝。运气差连野兔都捉不到，莫说黄酒，怕是连窝头都买不起。&lt;/p&gt;
&lt;p&gt;今日我照常出门，一无所获。眼见夕阳西斜，心头愈发不是滋味。本想再坚持几个时辰，奈何荒山野岭，狐仙野鬼横行，入夜怕是会中邪，悻悻而归。行至途中，时来运转，竟捉到只异鸟。&lt;/p&gt;
&lt;p&gt;此物五彩斑斓，尊贵不凡，应是鸟中王族，定能卖到好价钱。它不同寻常鸟类，既不慌乱，也不挣扎，异常之平静，怕是修出智慧。我心忐忑，此物神骏，非神即妖，卖了怕是要遭天谴，但眼下锅都揭不开了，也管不得许多。&lt;/p&gt;
&lt;p&gt;天色渐暗，我步伐越来越快，坊间常流传狐鬼志怪之事，虽不知真假，小心些总不会有错。&lt;/p&gt;
&lt;p&gt;过去半盏茶光景，又遇见一僧人，弱冠之年，俊秀非常，一袭僧衣却有些破烂。&lt;/p&gt;
&lt;p&gt;“这位施主，贫僧有礼了。”僧人表情祥和，盈盈双眼如同一个姑娘，问：“敢问盘山镇怎么走？”&lt;/p&gt;
&lt;p&gt;我便是盘山镇之人，自然知道怎么走，便道：“跟着我。”&lt;/p&gt;
&lt;p&gt;荒郊野岭，多个人也多个照应。&lt;/p&gt;
&lt;p&gt;僧人微施一礼，便跟在我身后。&lt;/p&gt;
&lt;p&gt;“和尚，你怎么一人跑到这来，瞧你孱孱弱弱，不怕被豺狼虎豹叼了去？”&lt;/p&gt;
&lt;p&gt;“贫僧行至此处迷了路，条条山路盘根错节，竟越陷越深，不得而出。”&lt;/p&gt;
&lt;p&gt;“此地复杂，外人皆晕头转向，亏得遇见了我，否则未必走得出。”&lt;/p&gt;
&lt;p&gt;“善哉，善哉。施主莫不是猎户？”&lt;/p&gt;
&lt;p&gt;我缄口不言。&lt;/p&gt;
&lt;p&gt;我就是猎户，却不与和尚说。前两年遇见一老和尚，劝诫我切莫杀生，因果轮回逃不得，人活一世应多行善事，少沾恶孽。我心头不悦，与那人不欢而散，自此不再与和尚道士谈论此事。&lt;/p&gt;
&lt;p&gt;这僧人却识相，见我不言语，也未深究，想来是开明之僧，没有许多迂腐。&lt;/p&gt;
&lt;p&gt;“施主今日可有收获？”他瞧我背负的麻袋鼓鼓囊囊，如是问。&lt;/p&gt;
&lt;p&gt;“猎到一只野鸡。”我信口胡诌。那神鸟俊逸不凡，能卖高价，所谓财不外露，自不肯实说。&lt;/p&gt;
&lt;p&gt;话音刚落，腹中绞痛，方才采摘的野果坏了肚子，我背到草木浓密之地，蹲身方便。&lt;/p&gt;
&lt;p&gt;僧人远远站着，夜色朦胧中看不真切，修长的身影犹如一颗细树。&lt;/p&gt;
&lt;p&gt;异鸟忽飞了出来，落在我肩头。我十分惊奇，麻袋分明被绑死了，它如何能出？更惊异的还在后面，此物竟能口吐人言，脆脆生生，宛如稚嫩孩童。&lt;/p&gt;
&lt;p&gt;“愚钝后生，死到临头还不自知。”&lt;/p&gt;
&lt;p&gt;我惊惧交加，一时不该如何是好。这真乃一介神物，我也是被贪婪蒙了心，做出这等蠢事，唯恐命不久矣，磕头如捣蒜，哀声讨饶。&lt;/p&gt;
&lt;p&gt;异鸟却道：“你前世积德，命不该绝，我奉邗山道人之命特来点化。那僧人乃一介妖僧，害人无数，待天色阴暗后便显现原形，吸了你的阳气。”&lt;/p&gt;
&lt;p&gt;它说完，扑棱着翅膀飞走了。&lt;/p&gt;
&lt;p&gt;我呆若木鸡。其实早就心存疑虑，孱弱僧人怎敢一人现身荒郊野岭？其中必有因果。异鸟一针见血，原来这是吸人阳气的妖僧，要害我的命。&lt;/p&gt;
&lt;p&gt;我无心方便，拿起土块匆匆擦了两下，提起裤子就逃。&lt;/p&gt;
&lt;p&gt;年轻僧人却好巧不好堵在我前面，微笑问：“你要往何处去？”&lt;/p&gt;
&lt;p&gt;我表情变幻，终究不敢点破，讪笑道：“我那野鸡逃了，四下找找。”&lt;/p&gt;
&lt;p&gt;僧人道：“一饮一啄皆由前定，野鸡既逃，便是命中无有，穷追也徒劳。”&lt;/p&gt;
&lt;p&gt;换做平常，我定要骂一句胡扯，如今却陪着笑点头哈腰。&lt;/p&gt;
&lt;p&gt;僧人问：“施主肚子好些没有？”&lt;/p&gt;
&lt;p&gt;我迟疑片刻，缓缓点头。&lt;/p&gt;
&lt;p&gt;僧人道：“那便赶路吧。”&lt;/p&gt;
&lt;p&gt;我走在前，他跟在后，总感如芒在背，内心不能踏实，便故意走得慢，与他平行，暗自握紧猎刀，真有个变故也好应对。&lt;/p&gt;
&lt;p&gt;“高僧去盘山镇作甚？”我心不在焉的问。&lt;/p&gt;
&lt;p&gt;“取一件法宝。”&lt;/p&gt;
&lt;p&gt;我暗自冷笑，盘山镇穷乡僻壤，莫说法宝，连僧庙都没有一个，明摆着胡诌。&lt;/p&gt;
&lt;p&gt;我虽不是恶人，长期打猎也有几分胆气，当机立断道：“莫要跟着我了。你走你的阳关道，我过我的独木桥，就此别过可好？”&lt;/p&gt;
&lt;p&gt;僧人笑吟吟望着我，一言未语，自岔路离去。&lt;/p&gt;
&lt;p&gt;我更加确信他就是妖僧。换做常人必会问其究竟，他不言不语，岂不是心头有鬼。&lt;/p&gt;
&lt;p&gt;我加快步伐，免得夜长梦多。&lt;/p&gt;
&lt;p&gt;天色完全暗下来，前路一片漆黑。山路难走，夜间更是分不清东南西北，饶是我熟悉地形也有些晕头转向，疾行一个时辰，理应回到盘山镇，却还在荒山中打转，不由焦急。&lt;/p&gt;
&lt;p&gt;茫然无措之际，前方人影若隐若现，我心头忐忑，缩在树后静观其变。&lt;/p&gt;
&lt;p&gt;那人遥遥呼道：“施主，见面即是缘，何必躲藏？”&lt;/p&gt;
&lt;p&gt;正是那妖僧！&lt;/p&gt;
&lt;p&gt;我见躲不开，硬着头皮现身，冷硬问：“你一直跟着我？”&lt;/p&gt;
&lt;p&gt;僧人微笑道：“施主多虑了。自打分离之后我便自走自的，却迷了方向，不知为何又撞见了你。”&lt;/p&gt;
&lt;p&gt;我却不信，哪有这般巧的事，必是被妖法迷了心智，苦困此地挣脱不得。&lt;/p&gt;
&lt;p&gt;他问：“施主也迷了路？”&lt;/p&gt;
&lt;p&gt;我不答，扭头便走。&lt;/p&gt;
&lt;p&gt;他却一直跟着我。&lt;/p&gt;
&lt;p&gt;我最初不敢理睬，只是闷头猛走，见甩不脱，被激起了火气，转身喝道：“你老跟着我作甚！”&lt;/p&gt;
&lt;p&gt;僧人合十施礼，道：“前路茫茫，山兽肆虐，多个人也有照应。”&lt;/p&gt;
&lt;p&gt;我见他狗皮膏药一样，自知逃不得，恶念横生，不如先下手为强！妖僧虽诡，洒家这刀也不是吃素的。&lt;/p&gt;
&lt;p&gt;趁着夜色，我虚与委蛇，握紧了猎刀缓缓逼近。&lt;/p&gt;
&lt;p&gt;一团火光迸发，映出我森寒的脸。我唬了一惊，赶忙将刀藏在身后，不敢妄动。&lt;/p&gt;
&lt;p&gt;僧人笑道：“山路难走，脚上磨出许多泡，我等歇息片刻可好？”&lt;/p&gt;
&lt;p&gt;我暗自松懈，看来他并未察觉。不动声色坐下，随时准备结果了他的性命。&lt;/p&gt;
&lt;p&gt;僧人盘膝而坐，自怀中掏出两条血淋淋的肉条，缠在树枝上便烤。&lt;/p&gt;
&lt;p&gt;我惊异问：“你这是作甚？”&lt;/p&gt;
&lt;p&gt;僧人道：“烤肉。”&lt;/p&gt;
&lt;p&gt;我问：“出家人还吃肉？”&lt;/p&gt;
&lt;p&gt;僧人笑道：“酒肉穿肠过，佛在心中坐。跋涉许久，总要补充体力，你也吃一条。”&lt;/p&gt;
&lt;p&gt;我心头发寒，自不敢吃。&lt;/p&gt;
&lt;p&gt;僧人笑而不语。待肉烤熟，自顾吃了起来，满嘴流油，哪里有高僧风范，与绿林劫匪无异。&lt;/p&gt;
&lt;p&gt;吃的这般心安理得，果是妖僧。&lt;/p&gt;
&lt;p&gt;我杀心已决，借口撒尿，绕到他背后。&lt;/p&gt;
&lt;p&gt;手起。&lt;/p&gt;
&lt;p&gt;刀未落。&lt;/p&gt;
&lt;p&gt;望着那抹俊秀背影，我犹豫不决。&lt;/p&gt;
&lt;p&gt;弱冠年华，就这样死了岂不太可惜？我好杀生，只因生计所迫，并非内心残忍。因莫须有罪名杀害一条性命，实在做不出。&lt;/p&gt;
&lt;p&gt;僧人察觉响动，扭过头来，见我猎刀高举，讶声问：“施主这是为何？”&lt;/p&gt;
&lt;p&gt;我面色变幻，最终叹息一声，道：“方才有只异鸟告诉我，你是妖僧，要害我性命。我不信。”&lt;/p&gt;
&lt;p&gt;僧人稍怔，旋而微笑道：“真巧。我也遇到一只异鸟，说你是官府通缉的凶犯，要谋我的财，害我的命，我也不信。”&lt;/p&gt;
&lt;p&gt;我闻言大惊，问：“此话当真？”&lt;/p&gt;
&lt;p&gt;僧人正色道：“出家人不打诳语。”&lt;/p&gt;
&lt;p&gt;我回过味来，心头大怒，骂道：“好妖魔！挑拨离间，妄图我二人自相残杀，端的恶毒！”&lt;/p&gt;
&lt;p&gt;僧人轻叹一声，用手贴住我的胸口，意味深长道：“妖魔不可怕，可怕的，是人的心魔。”&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我靠打猎谋生，运气好能猎到鹿或野猪等大野物，十天半月不愁吃喝。运气差连野兔都捉不到，莫说黄酒，怕是连窝头都买不起。&lt;/p&gt;
&lt;p&gt;今日我照常出门，一无所获。眼见夕阳西斜，心头愈发不是滋味。本想再坚持几个时辰，奈何荒山野岭，狐仙野鬼横行，入夜怕是会中邪，悻悻而归。行至途中，时
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>php使用phpmailer发送邮件</title>
    <link href="http://xwzmsdqbjzyyg.github.io/2016/08/12/phpmailer/"/>
    <id>http://xwzmsdqbjzyyg.github.io/2016/08/12/phpmailer/</id>
    <published>2016-08-12T08:36:53.000Z</published>
    <updated>2016-08-12T08:42:42.623Z</updated>
    
    <content type="html">&lt;p&gt;163邮箱&lt;/p&gt;
&lt;p&gt;//引入PHPMailer的核心文件 使用require_once包含避免出现PHPMailer类重复定义的警告&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;include(&amp;quot;PHP/class.smtp.php&amp;quot;);
include(&amp;quot;PHP/class.phpmailer.php&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//示例化PHPMailer核心类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail = new PHPMailer();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//是否启用smtp的debug进行调试 开发环境建议开启 生产环境注释掉即可 默认关闭debug调试模式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;SMTPDebug = 1;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//使用smtp鉴权方式发送邮件，当然你可以选择pop方式 sendmail方式等 本文不做详解&lt;br&gt;//可以参考&lt;a href=&quot;http://phpmailer.github.io/PHPMailer/当中的详细介绍&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://phpmailer.github.io/PHPMailer/当中的详细介绍&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;isSMTP();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//smtp需要鉴权 这个必须是true&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;SMTPAuth=true;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//链接qq域名邮箱的服务器地址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;Host = &amp;apos;smtp.163.com&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//设置使用ssl加密方式登录鉴权  因为163默认开启所以不要但是qq要这句&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//$mail-&amp;gt;SMTPSecure = &amp;apos;ssl&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//设置ssl连接smtp服务器的远程服务器端口号 可选465或587&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;Port = 25;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//设置smtp的helo消息头 这个可有可无 内容任意&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//$mail-&amp;gt;Helo = &amp;apos;Hello smtp.163.com Server&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//设置发件人的主机域 可有可无 默认为localhost 内容任意，建议使用你的域名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//$mail-&amp;gt;Hostname = &amp;apos;jjonline.cn&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//设置发送的邮件的编码 可选GB2312 我喜欢utf-8 据说utf8在某些客户端收信下会乱码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;CharSet = &amp;apos;UTF-8&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//设置发件人姓名（昵称） 任意内容，显示在收件人邮件的发件人邮箱地址前的发件人姓名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;FromName = &amp;apos;发件人姓名&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//smtp登录的账号 这里填入163邮箱账号即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;Username =&amp;apos;163邮箱账号&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//smtp登录的密码 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;Password = &amp;apos;授权码&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//设置发件人邮箱地址 这里填入上述提到的“发件人邮箱”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;From = &amp;apos;上述提到的&amp;quot;发件人邮箱和上面的163邮箱相同&amp;quot;&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//邮件正文是否为html编码 注意此处是一个方法 不再是属性 true或false&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;isHTML(true);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//设置收件人邮箱地址 该方法有两个参数 第一个参数为收件人邮箱地址 第二参数为给该地址设置的昵称 不同的邮箱系统会自动进行处理变动 这里第二个参数的意义不大&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;addAddress(&amp;apos;邮箱地址&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//添加多个收件人 则多次调用方法即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//$mail-&amp;gt;addAddress(&amp;apos;xxx@163.com&amp;apos;,&amp;apos;测试&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//添加该邮件的主题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;Subject = &amp;apos;测试&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//添加邮件正文 上方将isHTML设置成了true，则可以是完整的html字符串 如：使用file_get_contents函数读取本地的html文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;Body = &amp;quot;测试的验证码&amp;quot;.$token;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//为该邮件添加附件 该方法也有两个参数 第一个参数为附件存放的目录（相对目录、或绝对目录均可） 第二参数为在邮件附件中该附件的名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//$mail-&amp;gt;addAttachment(&amp;apos;./d.jpg&amp;apos;,&amp;apos;mm.jpg&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//同样该方法可以多次调用 上传多个附件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//$mail-&amp;gt;addAttachment(&amp;apos;./Jlib-1.1.0.js&amp;apos;,&amp;apos;Jlib.js&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//发送命令 返回布尔值&lt;br&gt;//PS：经过测试，要是收件人不存在，若不出现错误依然返回true 也就是说在发送之前 自己需要些方法实现检测该邮箱是否真实有效&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$status = $mail-&amp;gt;send();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//简单的判断与提示信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if($status) {
    echo &amp;apos;发送邮件成功&amp;apos;;
}else{
    echo &amp;apos;发送邮件失败，错误信息：&amp;apos;.$mail-&amp;gt;ErrorInfo;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; QQ邮箱&lt;/p&gt;
&lt;p&gt;//引入PHPMailer的核心文件 使用require_once包含避免出现PHPMailer类重复定义的警告&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;include(&amp;quot;PHP/class.smtp.php&amp;quot;);
include(&amp;quot;PHP/class.phpmailer.php&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//示例化PHPMailer核心类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail = new PHPMailer();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//是否启用smtp的debug进行调试 开发环境建议开启 生产环境注释掉即可 默认关闭debug调试模式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;SMTPDebug = 1;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//使用smtp鉴权方式发送邮件，当然你可以选择pop方式 sendmail方式等 本文不做详解&lt;br&gt;//可以参考&lt;a href=&quot;http://phpmailer.github.io/PHPMailer/当中的详细介绍&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://phpmailer.github.io/PHPMailer/当中的详细介绍&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;isSMTP();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//smtp需要鉴权 这个必须是true&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;SMTPAuth=true;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//链接qq域名邮箱的服务器地址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;Host = &amp;apos;smtp.qq.com&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//设置使用ssl加密方式登录鉴权  qq需要ssl登陆鉴权&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;SMTPSecure = &amp;apos;ssl&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//设置ssl连接smtp服务器的远程服务器端口号 可选465或587&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;Port = 465;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//设置smtp的helo消息头 这个可有可无 内容任意&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//$mail-&amp;gt;Helo = &amp;apos;Hello smtp.163.com Server&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//设置发件人的主机域 可有可无 默认为localhost 内容任意，建议使用你的域名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//$mail-&amp;gt;Hostname = &amp;apos;jjonline.cn&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//设置发送的邮件的编码 可选GB2312 我喜欢utf-8 据说utf8在某些客户端收信下会乱码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;CharSet = &amp;apos;UTF-8&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//设置发件人姓名（昵称） 任意内容，显示在收件人邮件的发件人邮箱地址前的发件人姓名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;FromName = &amp;apos;wangkun&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//smtp登录的账号 这里填入字符串格式的qq号即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;Username =&amp;apos;只要qq号码就好&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//smtp登录的密码 这里填入“独立密码” 若为设置“独立密码”则填入登录qq的密码 建议设置“独立密码”ssawncngrsjbbbdc&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;Password = &amp;apos;qq获取的授权码&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//设置发件人邮箱地址 这里填入上述提到的“发件人邮箱”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;From = &amp;apos;输入完整的邮箱账号&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//邮件正文是否为html编码 注意此处是一个方法 不再是属性 true或false&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;isHTML(true);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//设置收件人邮箱地址 该方法有两个参数 第一个参数为收件人邮箱地址 第二参数为给该地址设置的昵称 不同的邮箱系统会自动进行处理变动 这里第二个参数的意义不大&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;addAddress(&amp;apos;收件人邮箱&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//添加多个收件人 则多次调用方法即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//$mail-&amp;gt;addAddress(&amp;apos;xxx@163.com&amp;apos;,&amp;apos;晶晶在线用户&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//添加该邮件的主题&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;Subject = &amp;apos;标题&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//添加邮件正文 上方将isHTML设置成了true，则可以是完整的html字符串 如：使用file_get_contents函数读取本地的html文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mail-&amp;gt;Body = &amp;quot;你的内容&amp;quot;.$token;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//为该邮件添加附件 该方法也有两个参数 第一个参数为附件存放的目录（相对目录、或绝对目录均可） 第二参数为在邮件附件中该附件的名称&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//$mail-&amp;gt;addAttachment(&amp;apos;./d.jpg&amp;apos;,&amp;apos;mm.jpg&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//同样该方法可以多次调用 上传多个附件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//$mail-&amp;gt;addAttachment(&amp;apos;./Jlib-1.1.0.js&amp;apos;,&amp;apos;Jlib.js&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//发送命令 返回布尔值&lt;br&gt;//PS：经过测试，要是收件人不存在，若不出现错误依然返回true 也就是说在发送之前 自己需要些方法实现检测该邮箱是否真实有效&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$status = $mail-&amp;gt;send();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//简单的判断与提示信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if($status) {
    echo &amp;apos;发送邮件成功&amp;apos;;
}else{
    echo &amp;apos;发送邮件失败，错误信息：&amp;apos;.$mail-&amp;gt;ErrorInfo;
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;163邮箱&lt;/p&gt;
&lt;p&gt;//引入PHPMailer的核心文件 使用require_once包含避免出现PHPMailer类重复定义的警告&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;include(&amp;quot;PHP/class.smtp.php&amp;quot;);
include(&amp;qu
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>支付宝接口开发（即时到账）</title>
    <link href="http://xwzmsdqbjzyyg.github.io/2016/08/04/alipay/"/>
    <id>http://xwzmsdqbjzyyg.github.io/2016/08/04/alipay/</id>
    <published>2016-08-04T07:57:21.000Z</published>
    <updated>2016-08-04T08:03:32.993Z</updated>
    
    <content type="html">&lt;p&gt;准备企业PID，Key，企业支付宝账号   （注意，PID只要登录就能获取，但是Key需要支付宝的【支付密码】验证后才能获取。） demo下载：&lt;a href=&quot;https://b.alipay.com/order/techService.htm。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://b.alipay.com/order/techService.htm。&lt;/a&gt;&lt;br&gt;代码文件结构 ，使用注意部分  参阅 readme.txt&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create_direct_pay_by_user-php-UTF-8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  │&lt;br&gt;  ├lib┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈类文件夹&lt;br&gt;  │  │&lt;br&gt;  │  ├alipay_core.function.php ┈┈┈┈┈┈支付宝接口公用函数文件&lt;br&gt;  │  │&lt;br&gt;  │  ├alipay_notify.class.php┈┈┈┈┈┈┈支付宝通知处理类文件&lt;br&gt;  │  │&lt;br&gt;  │  ├alipay_submit.class.php┈┈┈┈┈┈┈支付宝各接口请求提交类文件&lt;br&gt;  │  │&lt;br&gt;  │  └alipay_md5.function.php┈┈┈┈┈┈┈支付宝接口MD5函数文件&lt;br&gt;  │&lt;br&gt;  ├log.txt┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈日志文件&lt;br&gt;  │&lt;br&gt;  ├alipay.config.php┈┈┈┈┈┈┈┈┈┈┈┈基础配置类文件&lt;br&gt;  │&lt;br&gt;  ├alipayapi.php┈┈┈┈┈┈┈┈┈┈┈┈┈┈支付宝接口入口文件&lt;br&gt;  │&lt;br&gt;  ├notify_url.php ┈┈┈┈┈┈┈┈┈┈┈┈┈服务器异步通知页面文件&lt;br&gt;  │&lt;br&gt;  ├return_url.php ┈┈┈┈┈┈┈┈┈┈┈┈┈页面跳转同步通知文件&lt;br&gt;  │&lt;br&gt;  ├cacert.pem ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈用于CURL中校验SSL的CA证书文件&lt;br&gt;  │&lt;br&gt;  └readme.txt ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈使用说明文本&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;结构分为两部分：接入部分与通知 返回 部分。接入部分即为传递参数等信息组合成超级链接，并用该链接来进行跳转。通知返回部分则是支付宝服务器对该笔订单处理完毕后，通知与返回该笔订单的详细信息到商户服务器，商&lt;br&gt;户服务器接收到后，并对其进行数据处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接入部分：&lt;/p&gt;
&lt;p&gt; 选定参数信息&lt;br&gt; 排序&lt;br&gt; 加密&lt;br&gt; 拼接字符串成URL链接&lt;br&gt; 自动跳转&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 alipay.config.php中对需要配置的参数信息已经有详细说明， 具体在项目中一般会在config.php中配置好，将lib下的类文件（可以重命名）以及cacert.pem 放置在项目的合适位置，确保能够正确引入。&lt;/p&gt;
&lt;p&gt;   构造 alipayapi.php中$parameter需要的参数 &lt;/p&gt;
&lt;p&gt;   /&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;请求参数&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;**&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;/&lt;br&gt;        //商户订单号，商户网站订单系统中唯一订单号，必填&lt;br&gt;        $out_trade_no = $_POST[‘WIDout_trade_no’];&lt;br&gt;        //订单名称，必填&lt;br&gt;        $subject = $_POST[‘WIDsubject’];&lt;br&gt;        //付款金额，必填&lt;br&gt;        $total_fee = $_POST[‘WIDtotal_fee’];&lt;br&gt;        //商品描述，可空&lt;br&gt;        $body = $_POST[‘WIDbody’];&lt;br&gt;/&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;em&gt;**&lt;/em&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;/&lt;br&gt;//构造要请求的参数数组，无需改动&lt;br&gt;$parameter = array(&lt;br&gt;        “service”       =&amp;gt; $alipay_config[‘service’],&lt;br&gt;        “partner”       =&amp;gt; $alipay_config[‘partner’],&lt;br&gt;        “seller_id”  =&amp;gt; $alipay_config[‘seller_id’],&lt;br&gt;        “payment_type”    =&amp;gt; $alipay_config[‘payment_type’],&lt;br&gt;        “notify_url”    =&amp;gt; $alipay_config[‘notify_url’],&lt;br&gt;        “return_url”    =&amp;gt; $alipay_config[‘return_url’],&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;anti_phishing_key&amp;quot;=&amp;gt;$alipay_config[&amp;apos;anti_phishing_key&amp;apos;],
&amp;quot;exter_invoke_ip&amp;quot;=&amp;gt;$alipay_config[&amp;apos;exter_invoke_ip&amp;apos;],
&amp;quot;out_trade_no&amp;quot;    =&amp;gt; $out_trade_no,
&amp;quot;subject&amp;quot;    =&amp;gt; $subject,
&amp;quot;total_fee&amp;quot;    =&amp;gt; $total_fee,
&amp;quot;body&amp;quot;    =&amp;gt; $body,
&amp;quot;_input_charset&amp;quot;    =&amp;gt; trim(strtolower($alipay_config[&amp;apos;input_charset&amp;apos;]))
//其他业务参数根据在线开发文档，添加参数.文档地址:https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7629140.0.0.kiX33I&amp;amp;treeId=62&amp;amp;articleId=103740&amp;amp;docType=1
//如&amp;quot;参数名&amp;quot;=&amp;gt;&amp;quot;参数值&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;);&lt;br&gt;//建立请求&lt;br&gt;$alipaySubmit = new AlipaySubmit($alipay_config);&lt;br&gt;$html_text = $alipaySubmit-&amp;gt;buildRequestForm($parameter,”get”, “确认”);&lt;br&gt;echo $html_text;&lt;br&gt;die;&lt;/p&gt;
&lt;p&gt;  需要注意的是开发支付接口需要在公网（服务器必须可以通过外网访问）才可以完成整个调试过程，如果服务器在外网访问不到，则无法接收到支付通知。&lt;/p&gt;
&lt;p&gt;   $notify_url和$return_url 需&lt;a href=&quot;http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问&lt;/a&gt; 。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;通知 返回 （具体业务逻辑在通知返回页面处理）&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://www.cnblogs.com/blodfox777/archive/2009/11/03/1595223.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/blodfox777/archive/2009/11/03/1595223.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;a) 返回页&lt;br&gt;传递给支付宝时的return_url参数所对应的页面文件。&lt;br&gt;具备的属性：&lt;br&gt;1、支付接口中买家的购买流程已经走到支付宝里且支付宝提示支付成功时，页面会自动跳转回自身网站的这个页面里来。&lt;br&gt;2、同步的，无时差&lt;br&gt;3、获得参数的方法是用get方式获取。&lt;br&gt;4、不论跳转回来程序判断是真还是假（$_GET[‘trade_status’] == ‘TRADE_FINISHED’ || $_GET[‘trade_status’] == ‘TRADE_SUCCESS’）只跳转回来一次，不重复。&lt;br&gt;5、这个并不是支付宝服务器调用了该页面，而是通过与组合拼接各参数形成的URL链接原理等同，拼接出来的URL链接，之后程序上做自动跳转。&lt;br&gt;6、基于5的原因，该页面的程序调试可不必在服务器上而是本机上调试、运行。&lt;br&gt;b) 通知页&lt;br&gt;传递给支付宝时的notify_url参数所对应的页面文件&lt;br&gt;具备的属性：&lt;br&gt;1、这个通知页就是被支付宝调用才能启动的。&lt;br&gt;2、服务器间的互动，不像返回页肉眼可以看到，这个是看不到的。&lt;br&gt;3、获得参数的方法是用POST方式获取。&lt;br&gt;4、支付宝中的该笔交易存在，且该笔交易状态发生了变更，就会被调用。&lt;br&gt;5、被调用程序判断（if(sign = mysign and responseTxt = true)），若我们自己在该判断中有做程序编写，成功则不再被调用，不成功则会反复被调用。&lt;br&gt;6、异步的，第一次收到订单信息（以下都称之为“通知”）是与返回页近乎等同或等同的同步时间，在判断不成功的情况下，会收到第二次第三次等次数的通知，时间间隔从最先的一两分钟，到后面的几个小时。失效时间是4&lt;br&gt;8小时。&lt;br&gt;7、基于6的原因，该页面的程序调试必须在服务器上调试、运行。&lt;br&gt;8、程序编写时必须采用程序执行成功，才写页面response.Write(“success”);，不成功则写页面response.Write(“fail”); 支付宝根据success来判定是否要重新再次发送通知。&lt;br&gt;9、该页面的Html页面中必须是空白、无任何Html标签、无任何空格。&lt;/p&gt;
&lt;p&gt;c) 在支付宝的众多接口中，不是所有的接口都拥有通知页与返回页的。&lt;br&gt;有的接口只有返回页；有的接口有通知页且用XML格式的内容显示在当前页面中；有的没有通知页也没有返回页仅仅只以XML格式的内容显示在当前页面中。所以，我们要根据各接口的技术文档与程序实例来做相应的数据处&lt;br&gt;理。&lt;br&gt;d) 大家这里存在一个疑问，一般大家的做法都是把数据库更新些在返回页中，但是很多情况下出现了订单不同步即掉单现象。这是为什么？&lt;br&gt;答：返回页是当前页面自动跳转的，这虽然跳转的反应速度不错，但人的手动关闭该页面操作绝对可以使之在没有跳转回来之前就关掉了该页面，此时原本该数据库更新的程序并没有被启动，这样直接导致了掉单，所以一般大商&lt;br&gt;户，尤其是网络游戏行业的即时到帐充值的技术做法是：返回页中有订单处理程序，通知页中也有，当返回页中的订单没做过处理时，通知页中的数据处理程序便启动；这样即可近乎100%解决掉单问题（还有种掉单原因是大家自己的服务器出现问题，比如MS3XML.DLL问题，这个问题至今没有什么可以解决的办法，只能重装或是更换服务器，也有的服务器因为中毒才导致的）。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;准备企业PID，Key，企业支付宝账号   （注意，PID只要登录就能获取，但是Key需要支付宝的【支付密码】验证后才能获取。） demo下载：&lt;a href=&quot;https://b.alipay.com/order/techService.htm。&quot; target=&quot;_bl
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP写入，读取与替换文件内容</title>
    <link href="http://xwzmsdqbjzyyg.github.io/2016/06/24/fopen-01/"/>
    <id>http://xwzmsdqbjzyyg.github.io/2016/06/24/fopen-01/</id>
    <published>2016-06-24T05:53:53.000Z</published>
    <updated>2016-06-24T05:55:02.867Z</updated>
    
    <content type="html">&lt;p&gt;完美实现PHP写入，读取，替换文件内容。先解释一下，主要用到：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fopen(&amp;quot;文件名.扩展名&amp;quot;,&amp;quot;操作方式&amp;quot;)
fwrite(读取的文件,&amp;quot;写入的文件&amp;quot;);
fclose(打开的对象变量);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;01     //写入文件&lt;br&gt;02     $str=”This is a test from www.nowamagic.netn”;&lt;br&gt;03     // w表示以写入的方式打开文件，如果文件不存在，系统会自动建立&lt;br&gt;04     $file_pointer = fopen(“aa.txt”,”a+”);&lt;br&gt;05     fwrite($file_pointer,$str);&lt;br&gt;06     fclose($file_pointer);&lt;br&gt;07     //读取文件&lt;br&gt;08      $file_name=”aa.txt”;&lt;br&gt;09      $fp=fopen($file_name,’r’);&lt;br&gt;10      while(!feof($fp))&lt;br&gt;11      {&lt;br&gt;12       $buffer=fgets($fp,4096);&lt;br&gt;13       //替换文件&lt;br&gt;14       $buffer = str_replace(“nowamagic”,”现代魔法”,$buffer);&lt;br&gt;15       $buffer = str_replace(“This is a test”,”这是一个实例”,$buffer);&lt;br&gt;16       echo $buffer.”&lt;br&gt;“;&lt;br&gt;17      }&lt;br&gt;18      fclose($fp);&lt;br&gt;fopen()&lt;/p&gt;
&lt;p&gt;fopen() 函数用于在 PHP 中打开文件，此函数的第一个参数含有要打开的文件的名称，第二个参数规定了使用哪种模式来打开文件。&lt;/p&gt;
&lt;p&gt;模式 描述&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;r 只读。在文件的开头开始。
r+ 读/写。在文件的开头开始。
w 只写。打开并清空文件的内容；如果文件不存在，则创建新文件。
w+ 读/写。打开并清空文件的内容；如果文件不存在，则创建新文件。
a 追加。打开并向文件文件的末端进行写操作，如果文件不存在，则创建新文件。
a+ 读/追加。通过向文件末端写内容，来保持文件内容。
x 只写。创建新文件。如果文件以存在，则返回 FALSE。
x+ 读/写。创建新文件。如果文件已存在，则返回 FALSE 和一个错误。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注释：如果 fopen() 无法打开指定文件，则返回 0 (false)。&lt;br&gt;feof()&lt;/p&gt;
&lt;p&gt;检测 End-of-file&lt;/p&gt;
&lt;p&gt;feof() 函数检测是否已达到文件的末端 (EOF)，在循环遍历未知长度的数据时，feof() 函数很有用。注释：在 w 、a 以及 x 模式，您无法读取打开的文件！&lt;br&gt;1     if (feof($file))&lt;br&gt;2         echo “End of file”;&lt;br&gt;fgets()&lt;/p&gt;
&lt;p&gt;fgets() 函数用于从文件中逐行读取文件。在调用该函数之后，文件指针会移动到下一行。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;完美实现PHP写入，读取，替换文件内容。先解释一下，主要用到：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fopen(&amp;quot;文件名.扩展名&amp;quot;,&amp;quot;操作方式&amp;quot;)
fwrite(读取的文件,&amp;quot;写入的文件&amp;quot;);
fclose(打开的对象变
    
    </summary>
    
    
      <category term="fopen、fwrite、fclose" scheme="http://xwzmsdqbjzyyg.github.io/tags/fopen%E3%80%81fwrite%E3%80%81fclose/"/>
    
  </entry>
  
  <entry>
    <title>PHP $_SERVER 转</title>
    <link href="http://xwzmsdqbjzyyg.github.io/2016/06/24/server-01/"/>
    <id>http://xwzmsdqbjzyyg.github.io/2016/06/24/server-01/</id>
    <published>2016-06-24T05:49:27.000Z</published>
    <updated>2016-06-24T05:53:35.981Z</updated>
    
    <content type="html">&lt;p&gt;$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。&lt;br&gt;下表列出了所有 $_SERVER 变量中的重要元素。&lt;/p&gt;
&lt;p&gt;元素/代码     描述&lt;br&gt;$_SERVER[‘PHP_SELF’]     &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        当前执行脚本的文件名，与 document root 有关。&lt;br&gt;$_SERVER[‘GATEWAY_INTERFACE’] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;            服务器使用的 CGI 规范的版本。&lt;br&gt;$_SERVER[‘SERVER_ADDR’]     &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;        当前运行脚本所在的服务器的 IP 地址。&lt;br&gt;$_SERVER[‘SERVER_NAME’]     &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。&lt;br&gt;$_SERVER[‘SERVER_SOFTWARE’] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    服务器标识字符串，在响应请求时的头信息中给出。&lt;br&gt;$_SERVER[‘SERVER_PROTOCOL’] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    请求页面时通信协议的名称和版本。&lt;br&gt;$_SERVER[‘REQUEST_METHOD’] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    访问页面使用的请求方法。&lt;br&gt;$_SERVER[‘REQUEST_TIME’]     &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;请求开始时的时间戳。从 PHP 5.1.0 起可用。&lt;br&gt;$_SERVER[‘QUERY_STRING’]     &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;query string（查询字符串），如果有的话，通过它进行页面访问。&lt;br&gt;$_SERVER[‘HTTP_ACCEPT’]     &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;当前请求头中 Accept: 项的内容，如果存在的话。&lt;br&gt;$_SERVER[‘HTTP_ACCEPT_CHARSET’] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    当前请求头中 Accept-Charset: 项的内容，如果存在的话。&lt;br&gt;$_SERVER[‘HTTP_HOST’]     &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;当前请求头中 Host: 项的内容，如果存在的话。&lt;br&gt;$_SERVER[‘HTTP_REFERER’] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。)&lt;br&gt;$_SERVER[‘HTTPS’] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。&lt;br&gt;$_SERVER[‘REMOTE_ADDR’] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    浏览当前页面的用户的 IP 地址。&lt;br&gt;$_SERVER[‘REMOTE_HOST’] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE_ADDR。&lt;br&gt;$_SERVER[‘REMOTE_PORT’] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    用户机器上连接到 Web 服务器所使用的端口号。&lt;br&gt;$_SERVER[‘SCRIPT_FILENAME’] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    当前执行脚本的绝对路径。&lt;br&gt;$_SERVER[‘SERVER_ADMIN’] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。&lt;br&gt;$_SERVER[‘SERVER_PORT’] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    Web 服务器使用的端口。默认值为 “80”。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。&lt;br&gt;$_SERVER[‘SERVER_SIGNATURE’] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    包含了服务器版本和虚拟主机名的字符串。&lt;br&gt;$_SERVER[‘PATH_TRANSLATED’] &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;    当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。&lt;br&gt;$_SERVER[‘SCRIPT_NAME’]     &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;包含当前脚本的路径。这在页面需要指向自己时非常有用。&lt;strong&gt;FILE&lt;/strong&gt; 常量包含当前脚本(例如包含文件)的完整路径和文件名。&lt;br&gt;$_SERVER[‘SCRIPT_URI’]     &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;URI 用来指定要访问的页面。例如 “/index.html”。&lt;/p&gt;
&lt;p&gt;下面是某网友整理的结果，可参考下。&lt;/p&gt;
&lt;p&gt;服务器变量 $_SERVER 详解：&lt;/p&gt;
&lt;p&gt;1、$_SESSION[‘PHP_SELF’] – 获取当前正在执行脚本的文件名&lt;/p&gt;
&lt;p&gt;2、$_SERVER[‘SERVER_PROTOCOL’] – 请求页面时通信协议的名称和版本。例如，“HTTP/1.0”。&lt;/p&gt;
&lt;p&gt;3、$_SERVER[‘REQUEST_TIME’] – 请求开始时的时间戳。从 PHP 5.1.0 起有效。和time函数效果一样。&lt;/p&gt;
&lt;p&gt;4、$_SERVER[‘argv’] – 传递给该脚本的参数。我试了下，get方法可以得到$_SERVER[‘argv’][0]；post方法无法给他赋值。&lt;/p&gt;
&lt;p&gt;5、$_SERVER[‘SERVER_NAME’] – 返回当前主机名。&lt;/p&gt;
&lt;p&gt;6、$_SERVER[‘SERVER_SOFTWARE’] – 服务器标识的字串，在响应请求时的头信息中给出。 如Microsoft-IIS/6.0&lt;/p&gt;
&lt;p&gt;7、$_SERVER[‘REQUEST_METHOD’] – 访问页面时的请求方法。例如：“GET”、“HEAD”，“POST”，“PUT”。&lt;/p&gt;
&lt;p&gt;8、$_SERVER[‘QUERY_STRING’] – 查询（query）的字符串（URL 中第一个问号 ? 之后的内容）。&lt;/p&gt;
&lt;p&gt;9、$_SERVER[‘DOCUMENT_ROOT’] – 当前运行脚本所在的文档根目录。在服务器配置文件中定义。 如E:\server&lt;/p&gt;
&lt;p&gt;10、$_SERVER[‘HTTP_ACCEPT’] – 当前请求的 Accept: 头信息的内容。&lt;/p&gt;
&lt;p&gt;11、$_SERVER[‘HTTP_ACCEPT_CHARSET’] – 当前请求的 Accept-Charset: 头信息的内容。例如：“iso-8859-1,*,utf-8”。&lt;/p&gt;
&lt;p&gt;12、$_SERVER[‘HTTP_ACCEPT_ENCODING’] – 当前请求的 Accept-Encoding: 头信息的内容。例如：“gzip”。&lt;/p&gt;
&lt;p&gt;13、$_SERVER[‘HTTP_ACCEPT_LANGUAGE’] – 当前请求的 Accept-Language: 头信息的内容。例如：“en”。&lt;/p&gt;
&lt;p&gt;14、$_SERVER[‘HTTP_CONNECTION’] – 当前请求的 Connection: 头信息的内容。例如：“Keep-Alive”。&lt;/p&gt;
&lt;p&gt;15、$_SERVER[‘HTTP_HOST’] – 当前请求的 Host: 头信息的内容。&lt;/p&gt;
&lt;p&gt;16、$_SERVER[‘HTTP_REFERER’] – 链接到当前页面的前一页面的 URL 地址。&lt;/p&gt;
&lt;p&gt;17、$_SERVER[‘HTTP_USER_AGENT’] – 返回用户使用的浏览器信息。也可以使用 get_browser() 得到此信息。&lt;/p&gt;
&lt;p&gt;18、$_SERVER[‘HTTPS’] – 如果通过https访问，则被设为一个非空的值，否则返回off.&lt;/p&gt;
&lt;p&gt;19、$_SERVER[‘REMOTE_ADDR’] – 正在浏览当前页面用户的 IP 地址。&lt;/p&gt;
&lt;p&gt;20、$_SERVER[‘REMOTE_HOST’] – 正在浏览当前页面用户的主机名。反向域名解析基于该用户的 REMOTE_ADDR。如本地测试返回127.0.0.1&lt;/p&gt;
&lt;p&gt;21、$_SERVER[‘REMOTE_PORT’] – 用户连接到服务器时所使用的端口。我在本机测试没通过，不知道什么原因。&lt;/p&gt;
&lt;p&gt;22、$_SERVER[‘SCRIPT_FILENAME’] – 当前执行脚本的绝对路径名。如返回E:\server\index.php&lt;/p&gt;
&lt;p&gt;23、$_SERVER[‘SERVER_ADMIN’] – 该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值&lt;/p&gt;
&lt;p&gt;24、$_SERVER[‘SERVER_PORT’] – 服务器所使用的端口。默认为“80”。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。&lt;/p&gt;
&lt;p&gt;25、$_SERVER[‘SERVER_SIGNATURE’] – 包含服务器版本和虚拟主机名的字符串。&lt;/p&gt;
&lt;p&gt;26、$_SERVER[‘PATH_TRANSLATED’] – 当前脚本所在文件系统（不是文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。 Apache 2 用 户可以使用 httpd.conf 中的 AcceptPathInfo On 来定义 PATH_INFO。&lt;/p&gt;
&lt;p&gt;27、$_SERVER[‘SCRIPT_NAME’] – 包含当前脚本的路径。这在页面需要指向自己时非常有用。&lt;strong&gt;FILE&lt;/strong&gt; 包含当前文件的绝对路径和文件名（例如包含文件）。&lt;/p&gt;
&lt;p&gt;28、$_SERVER[‘REQUEST_URI’] – 访问此页面所需的 URI。例如，“/index.html”。&lt;/p&gt;
&lt;p&gt;29、$_SERVER[‘PHP_AUTH_DIGEST’] – 当作为 Apache 模块运行时，进行 HTTP Digest 认证的过程中，此变量被设置成客户端发送的“Authorization”HTTP 头内容（以便作进一步的认证操作）。&lt;/p&gt;
&lt;p&gt;30、$_SERVER[‘PHP_AUTH_USER’]– 当 PHP 运行在 Apache 或 IIS（PHP 5 是 ISAPI）模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的用户名。&lt;/p&gt;
&lt;p&gt;31、$_SERVER[‘PHP_AUTH_PW’] – 当 PHP 运行在 Apache 或 IIS（PHP 5 是 ISAPI）模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的密码。&lt;/p&gt;
&lt;p&gt;32、$_SERVER[‘AUTH_TYPE’]–当 PHP 运行在 Apache 模块方式下，并且正在使用 HTTP 认证功能，这个变量便是认证的类型。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>memcache使用方法测试</title>
    <link href="http://xwzmsdqbjzyyg.github.io/2016/06/22/memcache-01/"/>
    <id>http://xwzmsdqbjzyyg.github.io/2016/06/22/memcache-01/</id>
    <published>2016-06-22T07:17:19.000Z</published>
    <updated>2016-06-22T07:19:53.029Z</updated>
    
    <content type="html">&lt;p&gt;//php操作memcache的使用测试总结–学习&lt;/p&gt;
&lt;p&gt;//1 Memcache::connect;&lt;/p&gt;
&lt;p&gt;   //$memcache = new Memcache;&lt;br&gt;   //$memcache-&amp;gt;connect(‘127.0.0.1’,11211) or die(“链接失败!”);&lt;/p&gt;
&lt;p&gt;//2 Memcache::pconnect; 长链接&lt;/p&gt;
&lt;p&gt;   //$memcache = new Memcache;&lt;br&gt;   //$ret = $memcache-&amp;gt;pconnect(‘127.0.0.1’,11211) or die(“链接失败”);&lt;br&gt;   //var_dump($ret);&lt;/p&gt;
&lt;p&gt;//3 Memcache::close; 关闭对象（对常链接不起作用）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*$memcache = new Memcache;
$memcache-&amp;gt;connect(&amp;apos;127.0.0.1&amp;apos;,11211) or die(&amp;quot;链接失败!&amp;quot;);
$result = $memcache-&amp;gt;close();
var_dump($result);*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//4 Memcache::addServer; 向对象添加一个服务器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*$mem = new Memcache;
$is_add = $mem-&amp;gt;addServer(&amp;apos;localhost&amp;apos;,11211,true, 1, 1, 15, true);
$is_set = $mem-&amp;gt;set(&amp;apos;key1&amp;apos;,&amp;apos;中华人民共和国&amp;apos;);
var_dump($is_set);*/

/*$mem = new Memcache;
$is_add = $mem-&amp;gt;addServer(&amp;apos;localhost&amp;apos;,11211,true, 1, 1, -1, false);
$is_set = $mem-&amp;gt;set(&amp;apos;key1&amp;apos;,&amp;apos;中华人民共和国&amp;apos;);
var_dump($is_set);*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//5 Memcache::add 添加一个要缓存的数据如果作为这个缓存的数据在键在服务器上还不存在的情况下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*$mem = new Memcache;
$is_add = $mem-&amp;gt;addServer(&amp;apos;localhost&amp;apos;,11211);
$is_set = $mem-&amp;gt;add(&amp;apos;key2&amp;apos;,&amp;apos;中华人民共和国&amp;apos;, false, 60);
var_dump($is_set);*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//6 Memcache::replace() 替换一个指定已存在key的缓存变量内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*$mem = new Memcache;
$is_add = $mem-&amp;gt;addServer(&amp;apos;localhost&amp;apos;,11211);
$mem-&amp;gt;add(&amp;apos;key2&amp;apos;,&amp;apos;中华人民共和国&amp;apos;, false, 60);
$is_set = $mem-&amp;gt;replace(&amp;apos;key2&amp;apos;,&amp;apos;台湾人民共和国&amp;apos;,false,60);
var_dump($is_set);*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//7 Memcace::set 设置一个指定key的缓存变量内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
$mem = new Memcache;
$is_add = $mem-&amp;gt;addServer(&amp;apos;localhost&amp;apos;,11211);
$mem-&amp;gt;set(&amp;apos;key2&amp;apos;,&amp;apos;中华人民共和国&amp;apos;, false, 60);
$key2 = $mem-&amp;gt;get(&amp;apos;key2&amp;apos;);
echo $key2.&amp;quot;&amp;lt;BR&amp;gt;&amp;quot;;
$mem-&amp;gt;replace(&amp;apos;key2&amp;apos;,&amp;apos;台湾人民&amp;apos;,false,60);
$key2 = $mem-&amp;gt;get(&amp;apos;key2&amp;apos;);
echo $key2;*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//8 Memcache::get() 获取某个key的变量缓存值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
$mem = new Memcache;
$is_add = $mem-&amp;gt;addServer(&amp;apos;localhost&amp;apos;,11211);
$mem-&amp;gt;set(&amp;apos;key2&amp;apos;,&amp;apos;中华人民共和国&amp;apos;, false, 60);
$mem-&amp;gt;set(&amp;apos;key1&amp;apos;,&amp;apos;台湾人民&amp;apos;,false,60);
$arr = $mem-&amp;gt;get(array(&amp;apos;key1&amp;apos;,&amp;apos;key2&amp;apos;));
var_dump($arr);
*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//9 Memcache::delete 删除某个变量的缓存&lt;br&gt;    /*&lt;br&gt;    $mem = new Memcache;&lt;br&gt;    $is_add = $mem-&amp;gt;addServer(‘localhost’,11211);&lt;br&gt;    $mem-&amp;gt;set(‘key2’,’中华人民共和国’, false, 60);&lt;br&gt;    $mem-&amp;gt;set(‘key1’,’台湾人民’,false,60);&lt;br&gt;    $mem-&amp;gt;delete(‘key2’);&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$arr = $mem-&amp;gt;get(array(&amp;apos;key1&amp;apos;,&amp;apos;key2&amp;apos;));
var_dump($arr);
*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//10 Memcach::flush 清空所缓存内容，不是真的删除缓存的内容，只是使所有变量的缓存过期，使内存中的内容被重写&lt;br&gt;    /*&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mem = new Memcache;
$is_add = $mem-&amp;gt;addServer(&amp;apos;localhost&amp;apos;,11211);
$mem-&amp;gt;flush();
*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//11 Memcach::getExtendedStats 获取所有服务器扩展静态信息&lt;br&gt;    /*&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mem = new Memcache;
$is_add = $mem-&amp;gt;addServer(&amp;apos;localhost&amp;apos;,11211);
$stats = $mem-&amp;gt;getExtendedStats();
var_dump($stats);
*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//12 Memcache:getStats; 获取最后添加服务器静态信息&lt;/p&gt;
&lt;p&gt;//13 Memcache::getServerStatus 通过输入的host及port来获取相应的服务器信息&lt;br&gt;    /*&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mem = new Memcache;
$is_add = $mem-&amp;gt;addServer(&amp;apos;localhost&amp;apos;,11211);
$info = $mem-&amp;gt;getServerStatus(&amp;apos;localhost&amp;apos;);
var_dump($info);
*/
//返回值
//返回服务器状态，0为失败，其他情况返回非0数字
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; //14 Memcache::getVersion() 获取服务器的版本号信息&lt;br&gt;    /*&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$mem = new Memcache;
$is_add = $mem-&amp;gt;addServer(&amp;apos;localhost&amp;apos;,11211);
$version = $mem-&amp;gt;getVersion();
echo $version;
*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; //15 Memcache::setCompressThreshold 设置压缩级根&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//bool Memcache::setCompressThreshold ( int $threshold [, float $min_savings ] )
//threshold 设置控制自动压缩的变量长度的最小值
//min_saving 指定的最低压缩比率，值必须介于 0 - 1 之间，默认为 0.2 代表 20% 的压缩比率
//$mem-&amp;gt;setCompressThreshold(20000,0.2);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;//16  Memcache::setServerParams   Memcache version 2.1.0后增加的函数，运行时设置服务器参数&lt;/p&gt;
&lt;p&gt;//17 Memcache::increment  给指定kye的缓存变量一个增值，如查该变量不是数字时不会被转化为数字&lt;br&gt;    //这个增值将会加到该变量原有的数字之上，变量不存在不会新增变量&lt;br&gt;    //对于压缩存储的变量不要使用本函数因为相应的取值方法会失败&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*
$mem = new Memcache;
$is_add = $mem-&amp;gt;addServer(&amp;apos;localhost&amp;apos;,11211);
$mem-&amp;gt;set(&amp;apos;key2&amp;apos;,11, false, 60);
$key  = $mem-&amp;gt;get(&amp;apos;key2&amp;apos;);
echo $key.&amp;quot;&amp;lt;BR&amp;gt;&amp;lt;BR&amp;gt;&amp;quot;;

$mem-&amp;gt;increment(&amp;apos;key2&amp;apos;,3);
$key = $mem-&amp;gt;get(&amp;apos;key2&amp;apos;);
echo $key;
*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; //18 Memcache::decrement&lt;br&gt;    //给指定key的缓存变量一个递减值，与increment操作类拟，将在原有变量基础上减去这个值，该项的值将会在转化为数字后减去，新项的值不会小于0，对于压缩的变量不要使用本函数因为相应的取值方法会失败&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*$mem = new Memcache;
$is_add = $mem-&amp;gt;addServer(&amp;apos;localhost&amp;apos;,11211);
$mem-&amp;gt;set(&amp;apos;key2&amp;apos;,11, false, 60);
$key  = $mem-&amp;gt;get(&amp;apos;key2&amp;apos;);
echo $key.&amp;quot;&amp;lt;BR&amp;gt;&amp;lt;BR&amp;gt;&amp;quot;;
$mem-&amp;gt;decrement(&amp;apos;key2&amp;apos;,3);
$key = $mem-&amp;gt;get(&amp;apos;key2&amp;apos;);
echo $key;*/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; //19 Memcache_debug&lt;br&gt;      //设置memecache的调用器是否开启，值为true或者false，受影响于php这安装时是否使用了 –enable-debug选项，如果使用了该函数才会返回true,其他情况将始终返回false&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;//php操作memcache的使用测试总结–学习&lt;/p&gt;
&lt;p&gt;//1 Memcache::connect;&lt;/p&gt;
&lt;p&gt;   //$memcache = new Memcache;&lt;br&gt;   //$memcache-&amp;gt;connect(‘127.0.0.1’,1
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>转 使用HAProxy,PHPRedis,和MySQL支撑10亿请求每周架构细节</title>
    <link href="http://xwzmsdqbjzyyg.github.io/2016/06/22/hprm-01/"/>
    <id>http://xwzmsdqbjzyyg.github.io/2016/06/22/hprm-01/</id>
    <published>2016-06-22T02:42:19.000Z</published>
    <updated>2016-06-22T03:16:24.649Z</updated>
    
    <content type="html">&lt;p&gt; 【编者按】在公司的发展中，保证服务器的可扩展性对于扩大企业的市场需要具有重要作用，因此，这对架构师提出了一定的要求。Octivi联合创始人兼软件架构师Antoni Orfin将向你介绍一个非常简单的架构，使用HAProxy、PHP、Redis和MySQL就能支撑每周10亿请求。同时，你还能了解项目未来的横向扩展途径及常见的模式。&lt;/p&gt;
&lt;p&gt;以下为译文：&lt;br&gt;&lt;img src=&quot;/images/hprm1.jpg&quot;&gt; &lt;/p&gt;
&lt;p&gt;在这篇文章中，我将展示一个非常简单的架构，使用HAProxy、PHP、Redis和MySQL支撑每周10亿请求。除此之外，我还将展示项目未来的横向扩展途径及常见的模式，下面我们一起看细节。&lt;/p&gt;
&lt;p&gt;状态：&lt;br&gt;.&lt;br&gt;    服务器&lt;br&gt;.&lt;br&gt;    3个应用程序节点&lt;br&gt;    2个MySQL+1个备份&lt;br&gt;    2个Redis&lt;br&gt;.&lt;br&gt;    应用程序&lt;br&gt;.&lt;br&gt;    应用程序每周处理10亿请求&lt;br&gt;    峰值700请求每秒的单Symfony2实例（平均工作日约550请求每秒）&lt;br&gt;    平均响应时间30毫秒&lt;br&gt;    Varnish，每秒请求超过1.2万次（压力测试过程中获得）&lt;br&gt;.&lt;br&gt;    数据存储&lt;br&gt;.&lt;br&gt;    Redis储存了1.6亿记录，数据体积大约100GB，同时它是我们的主要数据存储&lt;br&gt;    MySQL储存了3亿记录，数据体积大约300GB，通常情况下它作为三级缓存层&lt;/p&gt;
&lt;p&gt;平台：&lt;br&gt; &lt;img src=&quot;/images/hprm2.jpg&quot;&gt; &lt;/p&gt;
&lt;p&gt;.&lt;br&gt;    监视：&lt;br&gt;.&lt;br&gt;    Icinga&lt;br&gt;    Collectd&lt;br&gt;.&lt;br&gt;    应用程序&lt;br&gt;.&lt;br&gt;    HAProxy + Keepalived&lt;br&gt;    Varnish&lt;br&gt;    PHP（PHP-FPM）+ Symfony2 Framework&lt;br&gt;.&lt;br&gt;    数据存储&lt;br&gt;.&lt;br&gt;    MySQL（主从配置），使用HAProxy做负载均衡&lt;br&gt;    Redis （主从配置）&lt;br&gt;.&lt;br&gt;背景&lt;/p&gt;
&lt;p&gt;大约1年前，一个朋友找到我并提出了一个苛刻的要求：它们是一个飞速发展的电子商务初创公司，而当时已经准备向国际发展。介于那个时候他们仍然是一个创业公司，初始解决方案必须符合所谓的成本效益，因此也就无法在服务器上投入更多的资金。遗留系统使用了标准的LAMP堆栈，因此他们拥有一个强力的PHP开发团队。如果必须引入新技术的话，那么这些技术必须足够简单，不会存在太多架构上的复杂性；那么，他们当下的技术团队就可以对应用进行长期的维护。&lt;/p&gt;
&lt;p&gt;为了满足他们扩展到下一个市场的需求，架构师必须使用可扩展理念进行设计。首先，我们审视了他们的基础设施：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/hprm3.jpg&quot;&gt;&lt;br&gt;  &lt;img src=&quot;/images/hprm4.jpg&quot;&gt; &lt;/p&gt;
&lt;p&gt;老系统使用了单模块化设计思路，底层是一些基于PHP的Web应用程序。这个初创公司有许多所谓的前端网站，它们大多都使用了独立的数据库，并共享了一些支撑业务逻辑的通用代码。毫不客气的说，长期维护这种应用程序绝对是一个噩梦：因为随着业务的发展，有些代码必须被重写，这样的话，修改某个网站将不可避免导致业务逻辑上的不一致，这样一来，他们不得不在所有Web应用程序上做相同的修改。&lt;/p&gt;
&lt;p&gt;通常情况下，这该归结于项目管理问题，管理员必须对横跨多个代码库的那些代码负责。基于这个观点，整改第一步就是提取核心的业务关键功能，并将之拆分为独立的服务（这也是本文的一个重点部分），也就是所谓的面向服务架构，在整个系统内遵循“separation of concern”原则。每个服务只负责一个业务逻辑，同时也要明确更高等级的业务功能。举个形象的例子也就是，这个系统可能是个搜索引擎、一个销售系统等。&lt;/p&gt;
&lt;p&gt;前端网站通过REST API与服务交互，响应则基于JSON格式。为了简单起见，我们选择了SOAP，一个开发者比较无爱的协议，因为谁都不愿意解析一堆的XML。&lt;/p&gt;
&lt;p&gt;提取一些不会经常处理的服务，比如身份验证和会话管理。这是非常必要的一个环节，因为它们的处理等级比较高。前端网站负责这个部分，只有它们可以识别用户。这样一来我们可以保持服务的足够简单，在处理扩展和代码相关问题时都具有巨大的优势，可谓各司其职，完美无缺。&lt;/p&gt;
&lt;p&gt;带来的好处：&lt;br&gt;.&lt;br&gt;    独立子系统（服务）可以便捷的在不同团队中开发，开发者互不干涉，效率理所当然提升。&lt;br&gt;    身份验证和会话不会通过它们来管理，因此它们造成的扩展问题不翼而飞。&lt;br&gt;    业务逻辑被区分，不同的前端网站不会再存在功能冗余。&lt;br&gt;    显著地提高了服务的可用性。&lt;/p&gt;
&lt;p&gt;共生的缺点：&lt;/p&gt;
&lt;p&gt;为系统管理员带来更大的工作量。鉴于服务都使用了独立的基础设施，这将给管理员带来更多需要关注的地方。&lt;/p&gt;
&lt;p&gt;很难保持向后兼容。在一年的维护之后，API方法中发生了数不尽的变化。因此问题发生了，它们必将破坏向后兼容，因为每个网站的代码都可能发生变化，还可能存在许多技术人员同时修改一个网站的情况……然而，一年后，所有方法匹配的仍然是项目开始时建立的文档。&lt;/p&gt;
&lt;p&gt;应用程序层&lt;br&gt;&lt;img src=&quot;/images/hprm5.jpg&quot;&gt; &lt;/p&gt;
&lt;p&gt;着眼请求工作流，第一层是应用程序。HAProxy负载均衡器、Varnish和Symfony2应用程序都在这一层。来自前端网站的请求首先会传递给HAProxy，随后负载均衡器将把他分给不同的节点。&lt;/p&gt;
&lt;p&gt;应用程序节点配置&lt;br&gt;.&lt;br&gt;    Xeon E5-1620@3.60GHz，64GB RAM，SATA&lt;br&gt;    Varnish&lt;br&gt;    Apache2&lt;br&gt;    PHP 5.4.X（PHP-FPM），使用APC字节码缓存&lt;/p&gt;
&lt;p&gt;我们购买了3个这样的服务器，N+1冗余配置的active-active模式，备份服务器同样处理请求。因为性能不是首要因素，我们为每个节点配置独立的Varnish以降低缓存hit，同时也避免了单点故障（SPOF）。在这个项目中，我们更重视可用性。因为一个前端网站服务器中使用了Apache 2，我们保留了这个堆栈。这样一来，管理员不会困扰于太多新加入的技术。&lt;/p&gt;
&lt;p&gt;Symfony2应用程序&lt;/p&gt;
&lt;p&gt;应用程序本身基于Symfony2建立，这是一个PHP全堆栈框架，提供了大量加速开发的组件。作为基于复杂框架的典型REST服务可能受到很多人质疑，这里为你细说：&lt;br&gt;.&lt;br&gt;    对 PHP/Symfony 开发者友好。客户端IT团队由PHP开发者组成，添加新技术将意味必须招聘新的开发者，因为业务系统必须做长时间的维护。&lt;br&gt;    清晰的项目结构。 PHP/Symfony虽然从来都不是必需品，但却是许多项目的默认选择。引入新的开发者将非常方便，因为对他们来说代码非常友好。&lt;br&gt;    许多现成的组件。遵循DRY思想……没有人愿意花力气去做重复的工作，我们也不例外。我们使用了大量的Symfony2 Console Component，这个框架非常有利于做CLI命令，以及应用程序性能分析（debug工具栏）、记录器等。&lt;/p&gt;
&lt;p&gt;在选用Symfony2之前，我们做了大量的性能测试以保证应用程序可以支撑计划流量。我们制定了概念验证，并使用JMeter执行，我们得到了让人满意的结果——每秒700请求时响应时间可以控制在50毫秒。这些测试给了我们足够的信心，让我们坚信，即使Symfony2这样复杂的框架也可以得到理想的性能。&lt;/p&gt;
&lt;p&gt;应用程序分析与监控&lt;/p&gt;
&lt;p&gt;我们使用Symfony2工具来监视应用程序，在收集指定方法执行时间上表现的非常不错，特别是那些与第三方网络服务交互的操作。这样一来，我们可以发现架构中潜在的弱点，找出应用程序中最耗时的部分。&lt;/p&gt;
&lt;p&gt;冗长的日志同样是不可缺少的一部分，我们使用PHP Monolog库把这些日志处理成优雅的log-lines，便于开发者和管理员理解。这里需要注意的是尽可能多地添加细节，越详细越好，我们使用了不同的日志等级：&lt;br&gt;.&lt;br&gt;    Debug，可能会发生的事情。比如，请求信息在调用前会传送给一个外部Web服务；事情发生后从API调用响应。&lt;br&gt;    Error，当错误发生时请求流并未被终止，比如第三方API的错误响应。&lt;br&gt;    Critical，应用程序崩溃的瞬间。&lt;/p&gt;
&lt;p&gt;因此，你可以清晰地了解Error和Critical信息。而在开发/测试环境中，Debug信息同样被记录。同时，日志被存储在不同的文件中，也就是Monolog库下的“channels”。系统中有一个主日志文件，记录了所有应用程序级错误，以及各个channel的短日志，从单独的文件中记录了来自各个channel的详细日志。&lt;/p&gt;
&lt;p&gt;扩展性&lt;/p&gt;
&lt;p&gt;扩展平台的应用程序层并不困难，HAProxy性能并不会在短时间耗尽，唯一需要考虑的就是如何冗余以避免单点故障。因此，当下需要做的只是添加下一个应用程序节点。&lt;br&gt;数据层&lt;/p&gt;
&lt;p&gt;我们使用Redis和MySQL存储所有的数据，MySQL更多作为三级缓存层，而Redis则是系统的主要数据存储。&lt;br&gt;Redis&lt;/p&gt;
&lt;p&gt;在系统设计时，我们基于以下几点来选择满足计划需求的数据库：&lt;br&gt;.&lt;br&gt;    在存储大量数据时不会影响性能，大约2.5亿记录&lt;br&gt;    通常情况下多是基于特定资源的简单GET请求，没有查找及复杂的SELECT操作&lt;br&gt;    在单请求时尽可能多的获得资源以降低延时&lt;/p&gt;
&lt;p&gt;在经过一些调查后，我们决定使用Redis&lt;br&gt;.&lt;br&gt;    大部分我们执行的操作都具有 O（1）或O（N）复杂性， N是需要检索键的数量，这意味着keyspace大小并不会影响性能。&lt;br&gt;    通常情况下会使用MGET命令行同时检索100个以上的键，这样可以尽可能的避免网络延时，而不是在循环中做多重GET操作。&lt;/p&gt;
&lt;p&gt;我们当下拥有两个Redis服务器，使用主从复制模式。这两个节点的配置相同，都是Xeon E5-2650v2@2.60GHz，128GB，SSD。内存限制被设置为100GB，通常情况下使用率都是100%。&lt;br&gt;&lt;img src=&quot;/images/hprm6.jpg&quot;&gt; &lt;/p&gt;
&lt;p&gt;在应用程序并没有耗尽单个Redis服务器的所有资源时，从节点主要作作备份使用，用以保证高有效性。如果主节点宕机，我们可以快速的将应用程序切换到从节点。在维护和服务器迁移时，复制同样被执行——转换一个服务器非常简单。&lt;/p&gt;
&lt;p&gt;你可能会猜想当Redis资源被一直耗尽时的情景，所有的键都是持久化类型，大约占90% keyspace，剩余资源被全部被用于TTL过期缓存。当下，keyspace已经被分为两个部分：一个是TTL集（缓存），另一个则是用于持久化数据。感谢“volatile-lru”最大化内存设置的可行性，最不经常使用缓存键会被移除。如此一来，系统就可以一直保持单Redis实例同时执行两个操作——主存储和通用缓存。&lt;/p&gt;
&lt;p&gt;使用这个模式必须一直监视“期满”键的数量：&lt;/p&gt;
&lt;p&gt;db.redis1:6379&amp;gt; info keyspace&lt;/p&gt;
&lt;h1 id=&quot;Keyspace&quot;&gt;&lt;a href=&quot;#Keyspace&quot; class=&quot;headerlink&quot; title=&quot;Keyspace&quot;&gt;&lt;/a&gt;Keyspace&lt;/h1&gt;&lt;p&gt;db0:keys=16XXXXXXX,expires=11XXXXXX,avg_ttl=0&lt;/p&gt;
&lt;p&gt;“期满”键数量越接近0情况越危险，这个时候管理员就需要考虑适当的分片或者是增加内存。&lt;/p&gt;
&lt;p&gt;我们如何进行监控？这里使用Icinga check，仪表盘会显示数字是否会达到临界点，我们还使用了Redis来可视化“丢失键”的比率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/hprm7.jpg&quot;&gt; &lt;/p&gt;
&lt;p&gt;在一年后，我们已经爱上了Redis，它从未让我们失望，这一年系统从未发生任何宕机情况。&lt;br&gt;MySQL&lt;/p&gt;
&lt;p&gt;在Redis之外，我们还使用了传统RDBMS——MySQL。但是区别于他人，我们通常使用它作为三级缓存层。我们使用MySQL存储一些不会经常使用对象以降低Redis的资源使用率，因此它们被放到了硬盘上。这里没有什么可说道的地方，我们只是尽可能地让其保持简单。我们使用了两个MySQL服务器，配置是Xeon E5-1620@3.60GHz，64GB RAM，SSD。两个服务器使用本地、异步的主-主复制。此外，我们使用一个单独的从节点作为备份。&lt;/p&gt;
&lt;p&gt;MySQL的高可用性&lt;/p&gt;
&lt;p&gt;在应用程序中，数据库永远是最难的瓶颈。当前，这里还不需要考虑横向扩展操作，我们多是纵向扩展Redis和MySQL服务器。当下这个策略还存在一定的发展空间，Redis运行在一个126GB内存的服务器上，扩展到256GB也并不困难。当然，这样的服务器也存在劣势，比如快照，又或是是简单的启动——Redis服务器启动需要很长的时间。&lt;/p&gt;
&lt;p&gt;在纵向扩展失效后进行的必然是横向扩展，值得高兴的是，项目开始时我们就为数据准备了一个易于分片的结构：&lt;/p&gt;
&lt;p&gt;在Redis中，我们为记录使用了4个“heavy”类型。基于数据类型，它们可以分片到4个服务器上。我们避免使用哈希分片，而是选择基于记录类型分片。这种情况下，我们仍然可以运行MGET，它始终在一种类型键上执行。&lt;/p&gt;
&lt;p&gt;在MySQL上，结构化的表格非常易于向另一台服务器上迁移——同样基于记录类型（表格）。当然，一旦基于记录类型的分片不再奏效，我们将转移至哈希。&lt;br&gt;学到的知识&lt;br&gt;…..&lt;br&gt;    不要共享你的数据库。一旦一个前端网站期望切换会话处理到Redis，Redis缓存空间将被耗尽，同时它会拒绝应用程序保存下一个缓存键。这样一来所有的缓存将转至MySQL服务器，这将导致大量开销。&lt;br&gt;    日志越详细越好。如果log-lines中没有足够的信息，快速Debug问题定位将成为难点。如此一来，你不得不等待一个又一个问题发生，直到找到根结所在。&lt;br&gt;    架构中使用复杂的框架并不意味着低性能。许多人惊讶我们使用全堆栈框架来支撑如此流量应用程序，其秘诀在于更聪明的使用工具，否则即使是Node.js也可能变得很慢。选择一个提供良好开发环境的技术，没有人期望使用一堆不友好的工具，这将降低开发团队士气。&lt;/p&gt;
&lt;p&gt;查看原文：&lt;a href=&quot;http://blog.csdn.net/qiouyulei/article/details/38585901&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/qiouyulei/article/details/38585901&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; 【编者按】在公司的发展中，保证服务器的可扩展性对于扩大企业的市场需要具有重要作用，因此，这对架构师提出了一定的要求。Octivi联合创始人兼软件架构师Antoni Orfin将向你介绍一个非常简单的架构，使用HAProxy、PHP、Redis和MySQL就能支撑每周10亿
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>好玩的页面</title>
    <link href="http://xwzmsdqbjzyyg.github.io/2016/06/17/goods/"/>
    <id>http://xwzmsdqbjzyyg.github.io/2016/06/17/goods/</id>
    <published>2016-06-17T09:00:58.000Z</published>
    <updated>2016-06-17T05:47:41.706Z</updated>
    
    <content type="html">&lt;p&gt;光效在线生成&lt;br&gt;&lt;a href=&quot;http://yunyingyong.sinaapp.com/gx.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://yunyingyong.sinaapp.com/gx.htm&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;光效在线生成&lt;br&gt;&lt;a href=&quot;http://yunyingyong.sinaapp.com/gx.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://yunyingyong.sinaapp.com/gx.htm&lt;/a&gt;&lt;/p&gt;

    
    </summary>
    
    
      <category term="thinkphp" scheme="http://xwzmsdqbjzyyg.github.io/tags/thinkphp/"/>
    
  </entry>
  
  <entry>
    <title>PHP ob系列函数详解</title>
    <link href="http://xwzmsdqbjzyyg.github.io/2016/06/14/ob-01/"/>
    <id>http://xwzmsdqbjzyyg.github.io/2016/06/14/ob-01/</id>
    <published>2016-06-14T02:43:55.000Z</published>
    <updated>2016-06-14T03:19:11.270Z</updated>
    
    <content type="html">&lt;p&gt;什么是缓冲区?&lt;br&gt;简单而言,缓冲区的作用就是,把输入或者输出的内容先放进内存,而不显示或者读取.至于为什么要有缓冲区,这是一个很广泛的问题,如果有兴趣,可以在网山找下资料.&lt;br&gt;其实缓冲区最本质的作用就是,协调高速CPU和相对缓慢的IO设备(磁盘等)的运作.&lt;/p&gt;
&lt;p&gt;PHP在执行的时候,在什么地方有用到缓冲区?&lt;br&gt;想要了解PHP的缓冲区,就要知道执行PHP的时候,缓冲区被设置到了什么地方.&lt;br&gt;当执行PHP的时候,如果碰到了echo print_r之类的会输出数据的代码,PHP就会将要输出的数据放到PHP自身的缓冲区,等待输出.&lt;br&gt;当PHP自身的缓冲区接到指令,指示要输出缓冲区的内容时,将会把缓冲区内的数据输出到apache上, apache接受到PHP输出的数据,然后再把该数据存在到apache自身的缓冲区内,等到输出&lt;br&gt;当apache接受到指令,只是要输出缓冲区的内容时, 将会把缓冲区的内容输出,返回到浏览器.&lt;/p&gt;
&lt;p&gt;由此可见,PHP要输出数据的时候,将会经过两个缓冲区(先是自身的,然后是apache的),再返回到浏览器.&lt;/p&gt;
&lt;p&gt;缓冲区在PHP中起到什么作用?&lt;br&gt;1.最常见的就是在使用header函数之前,就已经输出了某些数据,这样会导致某些错误,例如 Cannot modify header information – headers already sent by;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;echo &amp;quot;this is test&amp;quot;;
header(&amp;quot;LOCATION http://www.baidu.com&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;出现这个错误的原因是, 在header之前已经输出了某些数据,而输出这些数据的同时, apache将会同时发送一个响应状态到浏览器上(既然有输出,即这个请求是有效的),而其后你又再次使用header函数&lt;br&gt;发送http头,则会返回这个错误,错误的意思是:HTTP头已经发送出去了,你不能对他再做修改.&lt;br&gt;为什么使用缓冲区可以避免这个错误呢?&lt;br&gt;因为header函数是不受缓冲区影响的,当一碰到header函数的时候,PHP马上执行apache发送这一个http头都浏览器.&lt;br&gt;而输出的数据PHP打开输出缓冲区后, 这些数据将会存放在缓冲区,等待输出.这样就可以避免了之前所发生的错误.&lt;br&gt;2.通过PHP写文件下载程序的时候.&lt;br&gt;为了让文件下载更安全,同时提高更多的可控性,很多朋友都喜欢用PHP写文件下载页面.其原理很简单,就是通过fwrite把文件内容读出并显示,然后通过header来发送HTTP头,让浏览器知道这是一个附件,这样&lt;br&gt;就可以达到提供下载的效果.&lt;br&gt;如果用上面的办法提供下载页面,会碰到一个效率问题,如果一个文件很大,假设为100M,那么在不开启缓冲区输出的情况下,必须要把100M数据全部读出,然后一次返回到页面上,如果这样做,用户将会在所有数据读完&lt;br&gt;之后才会得到响应,降低了用户体验感.&lt;br&gt;如果开启了输出缓冲区,当PHP程序读完文件的某一段,然后马上输出到apache,然后让apache马上返回到浏览器,这样就可以减少用户等待时间.那后面的数据怎么办呢?我们可以写一个while循环,一直一段一段地读取文件&lt;br&gt;每读一段,就马上输出,直到把文件全部输出为止,这样浏览器就可以持续地接受到数据,而不必等到所有文件读取完毕.&lt;/p&gt;
&lt;p&gt;另外,该做法还解决了另外一个很严重的问题.例如一个文件是100M,如果不开启缓冲区的情况下,则需要把100M文件全部读入内存,然后再输出.但是,如果PHP程序做了内存限制呢?为了保证服务器的稳定,管理员通常会把PHP的执行&lt;br&gt;内存设一个限制(通过php.ini总的memory_limit, 其默认值是8M), 也就是每个PHP程序使用的内存不能使用超过这个值的内存. 假设该值为8M,而要读入的文件是100M,根本就没有足够的内存来读入该文件.这个时候,我们就需要用到上面的&lt;br&gt;办法来解决这个问题,每次只读某一段,这样就可以避免了内存的限制&lt;br&gt;3.静态文件缓存&lt;br&gt;现在很多公司有这么一个需求, 就是某一个页面在第一次访问的时候,会执行PHP,然后把显示的内容返回到浏览器,同时需要把这次显示的内容保存到服务器上,这样下次访问的时候,就直接把保存在服务器上的文件直接显示,而不需要通过PHP来做操作&lt;br&gt;这就是所谓的”静态页面缓存”.那怎么样才能做到把内容返回到浏览器的同时把数据保存到服务器上呢?这就要用到输出缓冲区了.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ob_start();
echo &amp;apos;aaa&amp;apos;;
$string = ob_get_contents();
file_put_contents(&amp;apos;a.html&amp;apos;, $string);
ob_flush();
flush();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与输出缓冲区有关的配置&lt;br&gt;在PHP.INI中,有两个跟缓冲区紧密相关的配置项&lt;br&gt;1.output_buffering&lt;br&gt;该配置直接影响的是php本身的缓冲区,有3种配置参数.on/off/xK(x为某个整型数值);&lt;br&gt;on    - 开启缓冲区&lt;br&gt;off    - 关闭缓冲区&lt;br&gt;256k    - 开启缓冲区,而且当缓冲区的内容超过256k的时候,自动刷新缓冲区(把数据发送到apache);&lt;/p&gt;
&lt;p&gt;2.implicit_flush&lt;br&gt;该配置直接影响apache的缓冲区,有2种配置参数. on/off&lt;br&gt;on    - 自动刷新apache缓冲区,也就是,当php发送数据到apache的缓冲区的时候,不需要等待其他指令,直接就把输出返回到浏览器&lt;br&gt;off    - 不自动刷新apache缓冲区,接受到数据后,等待刷新指令&lt;/p&gt;
&lt;p&gt;与缓冲区有关的函数&lt;br&gt;1.ob_implicit_flush&lt;br&gt;作用和implicit_flush一样,是否自动刷新apache的缓冲区&lt;br&gt;2.flush&lt;br&gt;作用是发送指令到apache,让apache刷新自身的输出缓冲区.&lt;br&gt;3.ob_start&lt;br&gt;打开输出缓冲区,无论php.ini的文件如何配置,如果使用该函数,即使output_buffering设置成off,也会打开输出缓冲区&lt;br&gt;ob_start函数还接受一个参数,该参数是一个函数的回调,意思是,在输入缓冲区内容之前,需要使用调用传递进来的参数把缓冲区的内容处理一次,再放入缓冲区内&lt;br&gt;4.ob_flush&lt;br&gt;指示php本身刷新自身的缓冲区,把数据发送到apache&lt;br&gt;5.ob_clean&lt;br&gt;清除php缓冲区里面的内容&lt;br&gt;6.ob_end_clean&lt;br&gt;清除php缓冲区内的内容,并且关闭输出缓冲区&lt;br&gt;7.ob_end_flush&lt;br&gt;把php自身的缓冲区里的内容发送到apache,并把清除自身缓冲区内的内容&lt;br&gt;8.ob_get_clean&lt;br&gt;获取缓冲区的内容之后,清除缓冲区.&lt;br&gt;9.ob_get_contents&lt;br&gt;获取输出缓冲区里的内容&lt;br&gt;10.ob_get_flush&lt;br&gt;获取缓冲区里的内容,并且把这些内容发送到apache&lt;br&gt;11.ob_get_length&lt;br&gt;获取缓冲区里内容的长度&lt;br&gt;12.ob_list_handlers&lt;br&gt;获取运行ob_start时,所回调的函数名称, 例如:&lt;br&gt;ob_start(‘ob_gzhandler’);&lt;br&gt;print_r(ob_list_handlers);&lt;br&gt;将打印出ob_gzhandler;&lt;br&gt;13.ob_gzhandler&lt;br&gt;该函数的作用是作为ob_start的回调参数, 在缓冲区刷新之前,会调用该函数对数据进行到底gzip或者deflate压缩.这个函数需要zlib扩展的支持.&lt;/p&gt;
&lt;p&gt;使用缓冲区的相关内容&lt;br&gt;1.ob_flush和flush的次序关系.上面的分析可以看出,ob_flush是和php自身相关的,而flush操作的是apache的缓冲区,所有我们在使用这两个函数的时候,需要先执行ob_flush,&lt;br&gt;再执行flush,因为我们需要先把数据从PHP上发送到apache,然后再由apache返回到浏览器.如果php还没有把数据刷新到apache,就调用了flush,则apache无任何数据返回到浏览器.&lt;/p&gt;
&lt;p&gt;2.有的浏览器,如果接受到的字符太少,则不会把数据显示出来,例如老版的IE(必须要大于256k才显示).这样就会造成一个疑问, 明明在php和apache都进行了刷新缓冲区的操作,但是浏览器就是没有出现自己想要的数据,也许就是这个原因造成的.所以才测试的时候,可以在输出数据的后面加上多个空格,以填满数据,确定不会浏览器造成这类诡异的问题.&lt;/p&gt;
&lt;p&gt;3.有些webserver,他自身的输出缓冲区会有一些限制,比如nginx,他有一个配置fastcgi_buffer_size 4k, 就是是表明,当自身的输出缓冲区的内容达到4K才会刷新,所以为了保证内容的数据,可以添加以下代码,保证内容长度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php

echo str_repeat(&amp;quot; &amp;quot;,4096);

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.在apache中,如果你开启了mod_gzip的压缩模块,这样可能会导致你的flush函数刷新不成功,其原因是,mod_gzip有自己的输出缓冲区,当php执行了flush函数,指示apache刷新输出缓冲区,但是内容需要压缩,apache就把内容输出到自身的mod_gzip模块,mod_gzip也有自身的输出 缓冲区,他也不会马上输出,所以造成了内容不能马上输出.为了改善这个情况,可以关闭mod_gzip模块,或者在httpd.conf增加以下内容,以禁止压缩&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SetEnv no-gzip dont-vary
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;原文链接：&lt;a href=&quot;http://www.keepmyway.com/index.php/124.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.keepmyway.com/index.php/124.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;什么是缓冲区?&lt;br&gt;简单而言,缓冲区的作用就是,把输入或者输出的内容先放进内存,而不显示或者读取.至于为什么要有缓冲区,这是一个很广泛的问题,如果有兴趣,可以在网山找下资料.&lt;br&gt;其实缓冲区最本质的作用就是,协调高速CPU和相对缓慢的IO设备(磁盘等)的运作.&lt;/p&gt;

    
    </summary>
    
    
      <category term="php ob" scheme="http://xwzmsdqbjzyyg.github.io/tags/php-ob/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化的最佳20+条经验</title>
    <link href="http://xwzmsdqbjzyyg.github.io/2016/06/12/mysql-01/"/>
    <id>http://xwzmsdqbjzyyg.github.io/2016/06/12/mysql-01/</id>
    <published>2016-06-12T03:04:32.000Z</published>
    <updated>2016-06-12T09:19:03.220Z</updated>
    
    <content type="html">&lt;p&gt;今天，数据库的操作越来越成为整个应用的性能瓶颈了，这点对于Web应用尤其明显。关于数据库的性能，这并不只是DBA才需要担心的事，而这更是我们程序员需要去关注的事情。当我们去设计数据库表结构，对操作数据库时（尤其是查表时的SQL语句），我们都需要注意数据操作的性能。这里，我们不会讲过多的SQL语句的优化，而只是针对MySQL这一Web应用最多的数据库。希望下面的这些优化技巧对你有用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为查询缓存优化你的查询&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大多数的MySQL服务器都开启了查询缓存。这是提高性最有效的方法之一，而且这是被MySQL的数据库引擎处理的。当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。&lt;/p&gt;
&lt;p&gt;这里最主要的问题是，对于程序员来说，这个事情是很容易被忽略的。因为，我们某些查询语句会让MySQL不使用缓存。请看下面的示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/mysqlc1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;上面两条SQL语句的差别就是 CURDATE() ，MySQL的查询缓存对这个函数不起作用。所以，像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的。所以，你所需要的就是用一个变量来代替MySQL的函数，从而开启缓存。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;EXPLAIN 你的 SELECT 查询&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 EXPLAIN 关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。&lt;/p&gt;
&lt;p&gt;EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的，你的数据表是如何被搜索和排序的……等等，等等。&lt;/p&gt;
&lt;p&gt;挑一个你的SELECT语句（推荐挑选那个最复杂的，有多表联接的），把关键字EXPLAIN加到前面。你可以使用phpmyadmin来做这个事。然后，你会看到一张表格。下面的这个示例中，我们忘记加上了group_id索引，并且有表联接：&lt;br&gt;&lt;img src=&quot;/images/mysqlc2.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/mysqlc3.jpg&quot;&gt;&lt;br&gt;当我们为 group_id 字段加上索引后：&lt;br&gt;&lt;img src=&quot;/images/mysqlc4.jpg&quot;&gt;&lt;br&gt;&lt;img src=&quot;/images/mysqlc5.jpg&quot;&gt;&lt;br&gt;我们可以看到，前一个结果显示搜索了 7883 行，而后一个只是搜索了两个表的 9 和 16 行。查看rows列可以让我们找到潜在的性能问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当只要一行数据时使用 LIMIT 1&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。&lt;/p&gt;
&lt;p&gt;在这种情况下，加上 LIMIT 1 可以增加性能。这样一样，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。&lt;/p&gt;
&lt;p&gt;下面的示例，只是为了找一下是否有“中国”的用户，很明显，后面的会比前面的更有效率。（请注意，第一条中是Select *，第二条是Select 1）&lt;br&gt;&lt;img src=&quot;/images/mysqlc6.jpg&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为搜索字段建索引&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;索引并不一定就是给主键或是唯一的字段。如果在你的表中，有某个字段你总要会经常用来做搜索，那么，请为其建立索引吧。&lt;br&gt;&lt;img src=&quot;/images/mysqlc7.jpg&quot;&gt;&lt;br&gt;从上图你可以看到那个搜索字串 “last_name LIKE ‘a%’”，一个是建了索引，一个是没有索引，性能差了4倍左右。&lt;/p&gt;
&lt;p&gt;另外，你应该也需要知道什么样的搜索是不能使用正常的索引的。例如，当你需要在一篇大的文章中搜索一个词时，如： “WHERE post_content LIKE ‘%apple%’”，索引可能是没有意义的。你可能需要使用MySQL全文索引 或是自己做一个索引（比如说：搜索关键词或是Tag什么的）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在Join表的时候使用相当类型的例，并将其索引&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你的应用程序有很多 JOIN 查询，你应该确认两个表中Join的字段是被建过索引的。这样，MySQL内部会启动为你优化Join的SQL语句的机制。&lt;/p&gt;
&lt;p&gt;而且，这些被用来Join的字段，应该是相同的类型的。例如：如果你要把 DECIMAL 字段和一个 INT 字段Join在一起，MySQL就无法使用它们的索引。对于那些STRING类型，还需要有相同的字符集才行。（两个表的字符集有可能不一样）&lt;br&gt;&lt;img src=&quot;/images/mysqlc8.jpg&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;千万不要 ORDER BY RAND()&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;想打乱返回的数据行？随机挑一个数据？真不知道谁发明了这种用法，但很多新手很喜欢这样用。但你确不了解这样做有多么可怕的性能问题。&lt;/p&gt;
&lt;p&gt;如果你真的想把返回的数据行打乱了，你有N种方法可以达到这个目的。这样使用只让你的数据库的性能呈指数级的下降。这里的问题是：MySQL会不得不去执行RAND()函数（很耗CPU时间），而且这是为了每一行记录去记行，然后再对其排序。就算是你用了Limit 1也无济于事（因为要排序）&lt;/p&gt;
&lt;p&gt;下面的示例是随机挑一条记录&lt;br&gt;&lt;img src=&quot;/images/mysqlc9.jpg&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;避免 SELECT *&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。&lt;/p&gt;
&lt;p&gt;所以，你应该养成一个需要什么就取什么的好的习惯。&lt;br&gt;&lt;img src=&quot;/images/mysqlc10.jpg&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;永远为每张表设置一个ID&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的AUTO_INCREMENT标志。&lt;/p&gt;
&lt;p&gt;就算是你 users 表有一个主键叫 “email”的字段，你也别让它成为主键。使用 VARCHAR 类型来当主键会使用得性能下降。另外，在你的程序中，你应该使用表的ID来构造你的数据结构。&lt;/p&gt;
&lt;p&gt;而且，在MySQL数据引擎下，还有一些操作需要使用主键，在这些情况下，主键的性能和设置变得非常重要，比如，集群，分区……&lt;/p&gt;
&lt;p&gt;在这里，只有一个情况是例外，那就是“关联表”的“外键”，也就是说，这个表的主键，通过若干个别的表的主键构成。我们把这个情况叫做“外键”。比如：有一个“学生表”有学生的ID，有一个“课程表”有课程ID，那么，“成绩表”就是“关联表”了，其关联了学生表和课程表，在成绩表中，学生ID和课程ID叫“外键”其共同组成主键。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 ENUM 而不是 VARCHAR&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。&lt;/p&gt;
&lt;p&gt;如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。&lt;/p&gt;
&lt;p&gt;MySQL也有一个“建议”（见第十条）告诉你怎么去重新组织你的表结构。当你有一个 VARCHAR 字段时，这个建议会告诉你把其改成 ENUM 类型。使用 PROCEDURE ANALYSE() 你可以得到相关的建议。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从 PROCEDURE ANALYSE() 取得建议&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;PROCEDURE ANALYSE() 会让 MySQL 帮你去分析你的字段和其实际的数据，并会给你一些有用的建议。只有表中有实际的数据，这些建议才会变得有用，因为要做一些大的决定是需要有数据作为基础的。&lt;/p&gt;
&lt;p&gt;例如，如果你创建了一个 INT 字段作为你的主键，然而并没有太多的数据，那么，PROCEDURE ANALYSE()会建议你把这个字段的类型改成 MEDIUMINT 。或是你使用了一个 VARCHAR 字段，因为数据不多，你可能会得到一个让你把它改成 ENUM 的建议。这些建议，都是可能因为数据不够多，所以决策做得就不够准。&lt;/p&gt;
&lt;p&gt;在phpmyadmin里，你可以在查看表时，点击 “Propose table structure” 来查看这些建议&lt;br&gt;&lt;img src=&quot;/images/mysqlc11.jpg&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;尽可能的使用 NOT NULL&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除非你有一个很特别的原因去使用 NULL 值，你应该总是让你的字段保持 NOT NULL。这看起来好像有点争议，请往下看。&lt;/p&gt;
&lt;p&gt;首先，问问你自己“Empty”和“NULL”有多大的区别（如果是INT，那就是0和NULL）？如果你觉得它们之间没有什么区别，那么你就不要使用NULL。（你知道吗？在 Oracle 里，NULL 和 Empty 的字符串是一样的！)&lt;/p&gt;
&lt;p&gt;不要以为 NULL 不需要空间，其需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。 当然，这里并不是说你就不能使用NULL了，现实情况是很复杂的，依然会有些情况下，你需要使用NULL值。&lt;/p&gt;
&lt;p&gt;下面摘自MySQL自己的文档：&lt;br&gt;&lt;img src=&quot;/images/mysqlc12.jpg&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Prepared Statements&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Prepared Statements很像存储过程，是一种运行在后台的SQL语句集合，我们可以从使用 prepared statements 获得很多好处，无论是性能问题还是安全问题。&lt;/p&gt;
&lt;p&gt;Prepared Statements 可以检查一些你绑定好的变量，这样可以保护你的程序不会受到“SQL注入式”攻击。当然，你也可以手动地检查你的这些变量，然而，手动的检查容易出问题，而且很经常会被程序员忘了。当我们使用一些framework或是ORM的时候，这样的问题会好一些。&lt;/p&gt;
&lt;p&gt;在性能方面，当一个相同的查询被使用多次的时候，这会为你带来可观的性能优势。你可以给这些Prepared Statements定义一些参数，而MySQL只会解析一次。&lt;/p&gt;
&lt;p&gt;虽然最新版本的MySQL在传输Prepared Statements是使用二进制形势，所以这会使得网络传输非常有效率。&lt;/p&gt;
&lt;p&gt;当然，也有一些情况下，我们需要避免使用Prepared Statements，因为其不支持查询缓存。但据说版本5.1后支持了。&lt;/p&gt;
&lt;p&gt;在PHP中要使用prepared statements，你可以查看其使用手册：mysqli 扩展 或是使用数据库抽象层，如： PDO.&lt;br&gt;&lt;img src=&quot;/images/mysqlc13.jpg&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无缓冲的查询&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;正常的情况下，当你在当你在你的脚本中执行一个SQL语句的时候，你的程序会停在那里直到没这个SQL语句返回，然后你的程序再往下继续执行。你可以使用无缓冲查询来改变这个行为。&lt;/p&gt;
&lt;p&gt;关于这个事情，在PHP的文档中有一个非常不错的说明： mysql_unbuffered_query() 函数：&lt;br&gt;&lt;img src=&quot;/images/mysqlc14.jpg&quot;&gt;&lt;br&gt;上面那句话翻译过来是说，mysql_unbuffered_query() 发送一个SQL语句到MySQL而并不像mysql_query()一样去自动fethch和缓存结果。这会相当节约很多可观的内存，尤其是那些会产生大量结果的查询语句，并且，你不需要等到所有的结果都返回，只需要第一行数据返回的时候，你就可以开始马上开始工作于查询结果了。&lt;/p&gt;
&lt;p&gt;然而，这会有一些限制。因为你要么把所有行都读走，或是你要在进行下一次的查询前调用 mysql_free_result() 清除结果。而且， mysql_num_rows() 或 mysql_data_seek() 将无法使用。所以，是否使用无缓冲的查询你需要仔细考虑。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把IP地址存成 UNSIGNED INT&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;很多程序员都会创建一个 VARCHAR(15) 字段来存放字符串形式的IP而不是整形的IP。如果你用整形来存放，只需要4个字节，并且你可以有定长的字段。而且，这会为你带来查询上的优势，尤其是当你需要使用这样的WHERE条件：IP between ip1 and ip2。&lt;/p&gt;
&lt;p&gt;我们必需要使用UNSIGNED INT，因为 IP地址会使用整个32位的无符号整形。&lt;/p&gt;
&lt;p&gt;而你的查询，你可以使用 INET_ATON() 来把一个字符串IP转成一个整形，并使用 INET_NTOA() 把一个整形转成一个字符串IP。在PHP中，也有这样的函数 ip2long() 和 long2ip()。&lt;br&gt;&lt;img src=&quot;/images/mysqlc15.jpg&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;固定长度的表会更快&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果表中的所有字段都是“固定长度”的，整个表会被认为是 “static” 或 “fixed-length”。 例如，表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。&lt;/p&gt;
&lt;p&gt;固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。&lt;/p&gt;
&lt;p&gt;并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。&lt;/p&gt;
&lt;p&gt;使用“垂直分割”技术（见下一条），你可以分割你的表成为两个一个是定长的，一个则是不定长的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;垂直分割&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;“垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。（以前，在银行做过项目，见过一张表有100多个字段，很恐怖）&lt;/p&gt;
&lt;p&gt;示例一：在Users表中有一个字段是家庭地址，这个字段是可选字段，相比起，而且你在数据库操作的时候除了个人信息外，你并不需要经常读取或是改写这个字段。那么，为什么不把他放到另外一张表中呢？ 这样会让你的表有更好的性能，大家想想是不是，大量的时候，我对于用户表来说，只有用户ID，用户名，口令，用户角色等会被经常使用。小一点的表总是会有好的性能。&lt;/p&gt;
&lt;p&gt;示例二： 你有一个叫 “last_login” 的字段，它会在每次用户登录时被更新。但是，每次更新时会导致该表的查询缓存被清空。所以，你可以把这个字段放到另一个表中，这样就不会影响你对用户ID，用户名，用户角色的不停地读取了，因为查询缓存会帮你增加很多性能。&lt;/p&gt;
&lt;p&gt;另外，你需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去Join他们，不然的话，这样的性能会比不分割时还要差，而且，会是极数级的下降。&lt;/p&gt;
&lt;p&gt;会比不分割时还要差，而且，会是极数级的下降。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拆分大的 DELETE 或 INSERT 语句&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。&lt;/p&gt;
&lt;p&gt;Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。&lt;/p&gt;
&lt;p&gt;如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你泊WEB服务Crash，还可能会让你的整台服务器马上掛了。&lt;/p&gt;
&lt;p&gt;所以，如果你有一个大的处理，你定你一定把其拆分，使用 LIMIT 条件是一个好的方法。下面是一个示例：&lt;br&gt;&lt;img src=&quot;/images/mysqlc16.jpg&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;越小的列会越快&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。所以，把你的数据变得紧凑会对这种情况非常有帮助，因为这减少了对硬盘的访问。&lt;/p&gt;
&lt;p&gt;参看 MySQL 的文档 Storage Requirements 查看所有的数据类型。&lt;/p&gt;
&lt;p&gt;如果一个表只会有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。&lt;/p&gt;
&lt;p&gt;当然，你也需要留够足够的扩展空间，不然，你日后来干这个事，你会死的很难看，参看Slashdot的例子（2009年11月06日），一个简单的ALTER TABLE语句花了3个多小时，因为里面有一千六百万条数据。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择正确的存储引擎&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。酷壳以前文章《MySQL: InnoDB 还是 MyISAM?》讨论和这个事情。&lt;/p&gt;
&lt;p&gt;MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。&lt;/p&gt;
&lt;p&gt;InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。&lt;/p&gt;
&lt;p&gt;下面是MySQL的手册&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;target=”_blank”MyISAM Storage Engine
InnoDB Storage Engine
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;使用一个对象关系映射器（Object Relational Mapper）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 ORM (Object Relational Mapper)，你能够获得可靠的性能增涨。一个ORM可以做的所有事情，也能被手动的编写出来。但是，这需要一个高级专家。&lt;/p&gt;
&lt;p&gt;ORM 的最重要的是“Lazy Loading”，也就是说，只有在需要的去取值的时候才会去真正的去做。但你也需要小心这种机制的副作用，因为这很有可能会因为要去创建很多很多小的查询反而会降低性能。&lt;/p&gt;
&lt;p&gt;ORM 还可以把你的SQL语句打包成一个事务，这会比单独执行他们快得多得多。&lt;/p&gt;
&lt;p&gt;目前，个人最喜欢的PHP的ORM是：Doctrine。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;小心“永久链接”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;“永久链接”的目的是用来减少重新创建MySQL链接的次数。当一个链接被创建了，它会永远处在连接的状态，就算是数据库操作已经结束了。而且，自从我们的Apache开始重用它的子进程后——也就是说，下一次的HTTP请求会重用Apache的子进程，并重用相同的 MySQL 链接。&lt;/p&gt;
&lt;p&gt;PHP手册：mysql_pconnect()&lt;/p&gt;
&lt;p&gt;在理论上来说，这听起来非常的不错。但是从个人经验（也是大多数人的）上来说，这个功能制造出来的麻烦事更多。因为，你只有有限的链接数，内存问题，文件句柄数，等等。&lt;/p&gt;
&lt;p&gt;而且，Apache 运行在极端并行的环境中，会创建很多很多的了进程。这就是为什么这种“永久链接”的机制工作地不好的原因。在你决定要使用“永久链接”之前，你需要好好地考虑一下你的整个系统的架构。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天，数据库的操作越来越成为整个应用的性能瓶颈了，这点对于Web应用尤其明显。关于数据库的性能，这并不只是DBA才需要担心的事，而这更是我们程序员需要去关注的事情。当我们去设计数据库表结构，对操作数据库时（尤其是查表时的SQL语句），我们都需要注意数据操作的性能。这里，我们
    
    </summary>
    
    
      <category term="mysql" scheme="http://xwzmsdqbjzyyg.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>cookie 与 session</title>
    <link href="http://xwzmsdqbjzyyg.github.io/2016/06/08/cookie-01/"/>
    <id>http://xwzmsdqbjzyyg.github.io/2016/06/08/cookie-01/</id>
    <published>2016-06-08T09:20:26.000Z</published>
    <updated>2016-06-08T09:41:29.791Z</updated>
    
    <content type="html">&lt;p&gt;cookie简介&lt;/p&gt;
&lt;p&gt;Cookie是存储在客户端浏览器中的数据，我们通过Cookie来跟踪与存储用户数据。一般情况下，Cookie通过HTTP headers从服务端返回到客户端。多数web程序都支持Cookie的操作，因为Cookie是存在于HTTP的标头之中，所以必须在其他信息输出以前进行设置，类似于header函数的使用限制。&lt;/p&gt;
&lt;p&gt;PHP通过setcookie函数进行Cookie的设置，任何从浏览器发回的Cookie，PHP都会自动的将他存储在$_COOKIE的全局变量之中，因此我们可以通过$_COOKIE[‘key’]的形式来读取某个Cookie值。&lt;/p&gt;
&lt;p&gt;PHP中的Cookie具有非常广泛的使用，经常用来存储用户的登录信息，购物车等，且在使用会话Session时通常使用Cookie来存储会话id来识别用户，Cookie具备有效期，当有效期结束之后，Cookie会自动的从客户端删除。同时为了进行安全控制，Cookie还可以设置域跟路径，我们会在稍后的章节中详细的讲解他们。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
setcookie(&amp;apos;test&amp;apos;, time());
ob_start();//打开输出控制缓冲
print_r($_COOKIE);
$content = ob_get_contents();//复制缓冲区内容到$content中
$content = str_replace(&amp;quot; &amp;quot;, &amp;apos;&amp;amp;nbsp;&amp;apos;, $content);
ob_clean();//清空（擦掉）输出缓冲区
header(&amp;quot;content-type:text/html; charset=utf-8&amp;quot;);
echo &amp;apos;当前的Cookie为：&amp;lt;br/&amp;gt;&amp;apos;;
echo nl2br($content);//nl2br 在字符串所有新行之前插入 HTML 换行标记
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;设置cookie&lt;/p&gt;
&lt;p&gt;PHP设置Cookie最常用的方法就是使用setcookie函数，setcookie具有7个可选参数，我们常用到的为前5个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name（ Cookie名）可以通过$_COOKIE[&amp;apos;name&amp;apos;] 进行访问
value（Cookie的值）
expire（过期时间）Unix时间戳格式，默认为0，表示浏览器关闭即失效
path（有效路径）如果路径设置为&amp;apos;/&amp;apos;，则整个网站都有效
domain（有效域）默认整个域名都有效，如果设置了&amp;apos;www.icy.com&amp;apos;,则只在www子域中有效

$value = &amp;apos;test&amp;apos;;
setcookie(&amp;quot;TestCookie&amp;quot;, $value);
setcookie(&amp;quot;TestCookie&amp;quot;, $value, time()+3600);  //有效期一小时
setcookie(&amp;quot;TestCookie&amp;quot;, $value, time()+3600, &amp;quot;/path/&amp;quot;, &amp;quot;icy.com&amp;quot;); //设置路径与域
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PHP中还有一个设置Cookie的函数setrawcookie，setrawcookie跟setcookie基本一样，唯一的不同就是value值不会自动的进行urlencode，因此在需要的时候要手动的进行urlencode。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setrawcookie(&amp;apos;cookie_name&amp;apos;, rawurlencode($value), time()+60*60*24*365); 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为Cookie是通过HTTP标头进行设置的，所以也可以直接使用header方法进行设置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;header(&amp;quot;Set-Cookie:cookie_name=value&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;cookie的删除与过期时间&lt;/p&gt;
&lt;p&gt;们却发现php中没有删除Cookie的函数，在PHP中删除cookie也是采用setcookie函数来实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setcookie(&amp;apos;test&amp;apos;, &amp;apos;&amp;apos;, time()-1); 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到将cookie的过期时间设置到当前时间之前，则该cookie会自动失效，也就达到了删除cookie的目的。之所以这么设计是因为cookie是通过HTTP的标头来传递的，客户端根据服务端返回的Set-Cookie段来进行cookie的设置，如果删除cookie需要使用新的Del-Cookie来实现，则HTTP头就会变得复杂，实际上仅通过Set-Cookie就可以简单明了的实现Cookie的设置、更新与删除。&lt;/p&gt;
&lt;p&gt;了解原理以后，我们也可以直接通过header来删除cookie。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;header(&amp;quot;Set-Cookie:test=1393832059; expires=&amp;quot;.gmdate(&amp;apos;D, d M Y H:i:s \G\M\T&amp;apos;, time()-1));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里用到了gmdate，用来生成格林威治标准时间，以便排除时差的影响。&lt;br&gt;cookie的有效路径&lt;/p&gt;
&lt;p&gt;ookie中的路径用来控制设置的cookie在哪个路径下有效，默认为’/’，在所有路径下都有，当设定了其他路径之后，则只在设定的路径以及子路径下有效，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setcookie(‘test’, time(), 0, ‘/path’);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的设置会使test在/path以及子路径/path/abc下都有效，但是在根目录下就读取不到test的cookie值。&lt;/p&gt;
&lt;p&gt;一般情况下，大多是使用所有路径的，只有在极少数有特殊需求的时候，会设置路径，这种情况下只在指定的路径中才会传递cookie值，可以节省数据的传输，增强安全性以及提高性能。&lt;br&gt;当我们设置了有效路径的时候，不在当前路径的时候则看不到当前cookie。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setcookie(&amp;apos;test&amp;apos;, &amp;apos;1&amp;apos;,0, &amp;apos;/path&amp;apos;);  
var_dump($_COOKIE[&amp;apos;test&amp;apos;]);  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;session与cookie的异同&lt;/p&gt;
&lt;p&gt;cookie将数据存储在客户端，建立起用户与服务器之间的联系，通常可以解决很多问题，但是cookie仍然具有一些局限：&lt;/p&gt;
&lt;p&gt;cookie相对不是太安全，容易被盗用导致cookie欺骗&lt;br&gt;单个cookie的值最大只能存储4k&lt;br&gt;每次请求都要进行网络传输，占用带宽&lt;/p&gt;
&lt;p&gt;session是将用户的会话数据存储在服务端，没有大小限制，通过一个session_id进行用户识别，PHP默认情况下session id是通过cookie来保存的，因此从某种程度上来说，seesion依赖于cookie。但这不是绝对的，session id也可以通过参数来实现，只要能将session id传递到服务端进行识别的机制都可以使用session。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
//开始使用session
session_start();
//设置一个session
$_SESSION[&amp;apos;test&amp;apos;] = time();
//显示当前的session_id
echo &amp;quot;session_id:&amp;quot;.session_id();
echo &amp;quot;&amp;lt;br&amp;gt;&amp;quot;;

//读取session值
echo $_SESSION[&amp;apos;test&amp;apos;];

//销毁一个session
unset($_SESSION[&amp;apos;test&amp;apos;]);
echo &amp;quot;&amp;lt;br&amp;gt;&amp;quot;;
var_dump($_SESSION);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用session&lt;/p&gt;
&lt;p&gt;在PHP中使用session非常简单，先执行session_start方法开启session，然后通过全局变量$_SESSION进行session的读写。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;session_start();
$_SESSION[&amp;apos;test&amp;apos;] = time();
var_dump($_SESSION);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;session会自动的对要设置的值进行encode与decode，因此session可以支持任意数据类型，包括数据与对象等。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;session_start();
$_SESSION[&amp;apos;ary&amp;apos;] = array(&amp;apos;name&amp;apos; =&amp;gt; &amp;apos;jobs&amp;apos;);
$_SESSION[&amp;apos;obj&amp;apos;] = new stdClass();
var_dump($_SESSION);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;默认情况下，session是以文件形式存储在服务器上的，因此当一个页面开启了session之后，会独占这个session文件，这样会导致当前用户的其他并发访问无法执行而等待。可以采用缓存或者数据库的形式存储来解决这个问题，这个我们会在一些高级的课程中讲到。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
//在这里设置name的session值为jobs
session_start();
$_SESSION[&amp;apos;name&amp;apos;]=&amp;apos;xuehairong&amp;apos;;
$_SESSION[&amp;apos;obj&amp;apos;] = new stdClass();
var_dump($_SESSION);
echo $_SESSION[&amp;apos;name&amp;apos;];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;array(2) {
  [&amp;quot;name&amp;quot;]=&amp;gt;
  string(10) &amp;quot;xuehairong&amp;quot;
  [&amp;quot;obj&amp;quot;]=&amp;gt;
  object(stdClass)#1 (0) {
  }
}
xuehairong
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除与销毁session&lt;/p&gt;
&lt;p&gt;删除某个session值可以使用PHP的unset函数，删除后就会从全局变量$_SESSION中去除，无法访问。&lt;/p&gt;
&lt;p&gt;如果要删除所有的session，可以使用session_destroy函数销毁当前session，session_destroy会删除所有数据，但是session_id仍然存在。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;session_start();
$_SESSION[&amp;apos;name&amp;apos;] = &amp;apos;jobs&amp;apos;;
unset($_SESSION[&amp;apos;name&amp;apos;]);
echo $_SESSION[&amp;apos;name&amp;apos;]; //提示name不存在

session_start();
$_SESSION[&amp;apos;name&amp;apos;] = &amp;apos;jobs&amp;apos;;
$_SESSION[&amp;apos;time&amp;apos;] = time();
session_destroy();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;值得注意的是，session_destroy并不会立即的销毁全局变量$_SESSION中的值，只有当下次再访问的时候，$_SESSION才为空，因此如果需要立即销毁$_SESSION，可以使用unset函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;session_start();
$_SESSION[&amp;apos;name&amp;apos;] = &amp;apos;jobs&amp;apos;;
$_SESSION[&amp;apos;time&amp;apos;] = time();
unset($_SESSION);
session_destroy(); 
var_dump($_SESSION); //此时已为空
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果需要同时销毁cookie中的session_id，通常在用户退出的时候可能会用到，则还需要显式的调用setcookie方法删除session_id的cookie值。&lt;br&gt;使用session来存储用户的登录信息&lt;/p&gt;
&lt;p&gt;ession可以用来存储多种类型的数据，因此具有很多的用途，常用来存储用户的登录信息，购物车数据，或者一些临时使用的暂存数据等。&lt;/p&gt;
&lt;p&gt;用户在登录成功以后，通常可以将用户的信息存储在session中，一般的会单独的将一些重要的字段单独存储，然后所有的用户信息独立存储。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$_SESSION[&amp;apos;uid&amp;apos;] = $userinfo[&amp;apos;uid&amp;apos;];
$_SESSION[&amp;apos;userinfo&amp;apos;] = $userinfo;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一般来说，登录信息既可以存储在sessioin中，也可以存储在cookie中，他们之间的差别在于session可以方便的存取多种数据类型，而cookie只支持字符串类型，同时对于一些安全性比较高的数据，cookie需要进行格式化与加密存储，而session存储在服务端则安全性较高。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
session_start();
//假设用户登录成功获得了以下用户数据
$userinfo = array(
    &amp;apos;uid&amp;apos;  =&amp;gt; 10000,
    &amp;apos;name&amp;apos; =&amp;gt; &amp;apos;spark&amp;apos;,
    &amp;apos;email&amp;apos; =&amp;gt; &amp;apos;spark@icy.com&amp;apos;,
    &amp;apos;sex&amp;apos;  =&amp;gt; &amp;apos;woman&amp;apos;,
    &amp;apos;age&amp;apos;  =&amp;gt; &amp;apos;18&amp;apos;
);
header(&amp;quot;content-type:text/html; charset=utf-8&amp;quot;);

/* 将用户信息保存到session中 */
$_SESSION[&amp;apos;uid&amp;apos;] = $userinfo[&amp;apos;uid&amp;apos;];
$_SESSION[&amp;apos;name&amp;apos;] = $userinfo[&amp;apos;name&amp;apos;];
$_SESSION[&amp;apos;userinfo&amp;apos;] = $userinfo;

//* 将用户数据保存到cookie中的一个简单方法 */
$secureKey = &amp;apos;icy&amp;apos;; //加密密钥
$str = serialize($userinfo); //将用户信息序列化
//用户信息加密前
$str = base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, md5($secureKey), $str, MCRYPT_MODE_ECB));
//用户信息加密后
//将加密后的用户数据存储到cookie中
setcookie(&amp;apos;userinfo&amp;apos;, $str);

//当需要使用时进行解密
$str = mcrypt_decrypt(MCRYPT_RIJNDAEL_256, md5($secureKey), base64_decode($str), MCRYPT_MODE_ECB);
$uinfo = unserialize($str);
echo &amp;quot;解密后的用户信息：&amp;lt;br&amp;gt;&amp;quot;;
print_r($uinfo);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;解密后的用户信息：&lt;br&gt;    Array&lt;br&gt;    (&lt;br&gt;        [uid] =&amp;gt; 10000&lt;br&gt;        [name] =&amp;gt; spark&lt;br&gt;        [email] =&amp;gt; spark@icy.com&lt;br&gt;        [sex] =&amp;gt; man&lt;br&gt;        [age] =&amp;gt; 18&lt;br&gt;    )&lt;/p&gt;
&lt;p&gt;读取文件内容&lt;/p&gt;
&lt;p&gt;PHP具有丰富的文件操作函数，最简单的读取文件的函数为file_get_contents，可以将整个文件全部读取到一个字符串中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$content = file_get_contents(&amp;apos;./test.txt&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;file_get_contents也可以通过参数控制读取内容的开始点以及长度。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$content = file_get_contents(&amp;apos;./test.txt&amp;apos;, null, null, 100, 500);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PHP也提供类似于C语言操作文件的方法，使用fopen，fgets，fread等方法，fgets可以从文件指针中读取一行，freads可以读取指定长度的字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$fp = fopen(&amp;apos;./text.txt&amp;apos;, &amp;apos;rb&amp;apos;);
while(!feof($fp)) {
    echo fgets($fp); //读取一行
}
fclose($fp);




$fp = fopen(&amp;apos;./text.txt&amp;apos;, &amp;apos;rb&amp;apos;);
$contents = &amp;apos;&amp;apos;;
while(!feof($fp)) {
    $contents .= fread($fp, 4096); //一次读取4096个字符
}
fclose($fp);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用fopen打开的文件，最好使用fclose关闭文件指针，以避免文件句柄被占用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$filename = &amp;apos;/data/webroot/usercode/resource/test.txt&amp;apos;;
//编写代码读取$filename的文件内容
$contents=file_get_contents($filename);
echo $contents;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;this is a test file.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;判断文件是否存在&lt;/p&gt;
&lt;p&gt;一般情况下在对文件进行操作的时候需要先判断文件是否存在，PHP中常用来判断文件存在的函数有两个is_file与file_exists.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$filename = &amp;apos;./test.txt&amp;apos;;
if (file_exists($filename)) {
    echo file_get_contents($filename);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果只是判断文件存在，使用file_exists就行，file_exists不仅可以判断文件是否存在，同时也可以判断目录是否存在，从函数名可以看出，is_file是确切的判断给定的路径是否是一个文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$filename = &amp;apos;./test.txt&amp;apos;;
if (is_file($filename)) {
    echo file_get_contents($filename);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更加精确的可以使用is_readable与is_writeable在文件是否存在的基础上，判断文件是否可读与可写。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$filename = &amp;apos;./test.txt&amp;apos;;
if (is_writeable($filename)) {
    file_put_contents($filename, &amp;apos;test&amp;apos;);
}
if (is_readable($filename)) {
    echo file_get_contents($filename);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;写入内容到文件&lt;/p&gt;
&lt;p&gt;与读取文件对应，PHP写文件也具有两种方式，最简单的方式是采用file_put_contents。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$filename = &amp;apos;./test.txt&amp;apos;;
$data = &amp;apos;test&amp;apos;;
file_put_contents($filename, $data);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上例中，$data参数可以是一个一维数组，当$data是数组的时候，会自动的将数组连接起来，相当于$data=implode(‘’, $data);&lt;/p&gt;
&lt;p&gt;同样的，PHP也支持类似C语言风格的操作方式，采用fwrite进行文件写入。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$fp = fopen(&amp;apos;./test.txt&amp;apos;, &amp;apos;w&amp;apos;);
fwrite($fp, &amp;apos;hello&amp;apos;);
fwrite($fp, &amp;apos;world&amp;apos;);
fclose($fp);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;取得文件的修改时间&lt;/p&gt;
&lt;p&gt;文件有很多元属性，包括：文件的所有者、创建时间、修改时间、最后的访问时间等。&lt;/p&gt;
&lt;p&gt;fileowner：获得文件的所有者&lt;br&gt;filectime：获取文件的创建时间&lt;br&gt;filemtime：获取文件的修改时间&lt;br&gt;fileatime：获取文件的访问时间&lt;/p&gt;
&lt;p&gt;其中最常用的是文件的修改时间，通过文件的修改时间，可以判断文件的时效性，经常用在静态文件或者缓存数据的更新。&lt;/p&gt;
&lt;p&gt;$mtime = filemtime($filename);&lt;br&gt;echo ‘修改时间：’.date(‘Y-m-d H:i:s’, filemtime($filename));&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?php
$filename = &amp;apos;/data/webroot/usercode/code/resource/test.txt&amp;apos;;
echo &amp;apos;所有者：&amp;apos;.fileowner($filename).&amp;apos;&amp;lt;br&amp;gt;&amp;apos;;
echo &amp;apos;创建时间：&amp;apos;.filectime($filename).&amp;apos;&amp;lt;br&amp;gt;&amp;apos;;
echo &amp;apos;修改时间：&amp;apos;.filemtime($filename).&amp;apos;&amp;lt;br&amp;gt;&amp;apos;;
echo &amp;apos;最后访问时间：&amp;apos;.fileatime($filename).&amp;apos;&amp;lt;br&amp;gt;&amp;apos;;

//给$mtime赋值为文件的修改时间
$mtime = filemtime($filename);; 
//通过计算时间差 来判断文件内容是否有效
if (time() - $mtime &amp;gt; 3600) {
    echo &amp;apos;&amp;lt;br&amp;gt;缓存已过期&amp;apos;;
} else {
    echo file_get_contents($filename);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;所有者：501
创建时间：1446715450
修改时间：1446715450
最后访问时间：1460473202
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;缓存已过期&lt;/p&gt;
&lt;p&gt;取得文件的大小&lt;/p&gt;
&lt;p&gt;通过filesize函数可以取得文件的大小，文件大小是以字节数表示的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$filename = &amp;apos;/data/webroot/usercode/code/resource/test.txt&amp;apos;;
$size = filesize($filename);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果要转换文件大小的单位，可以自己定义函数来实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function getsize($size, $format = &amp;apos;kb&amp;apos;) {
    $p = 0;
    if ($format == &amp;apos;kb&amp;apos;) {
        $p = 1;
    } elseif ($format == &amp;apos;mb&amp;apos;) {
        $p = 2;
    } elseif ($format == &amp;apos;gb&amp;apos;) {
        $p = 3;
    }
    $size /= pow(1024, $p);
    return number_format($size, 3);
}

$filename = &amp;apos;/data/webroot/usercode/code/resource/test.txt&amp;apos;;
$size = filesize($filename);

$size = getsize($size, &amp;apos;kb&amp;apos;); //进行单位转换
echo $size.&amp;apos;kb&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;值得注意的是，没法通过简单的函数来取得目录的大小，目录的大小是该目录下所有子目录以及文件大小的总和，因此需要通过递归的方法来循环计算目录的大小。&lt;br&gt;删除文件&lt;/p&gt;
&lt;p&gt;跟Unix系统命令类似，PHP使用unlink函数进行文件删除。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unlink($filename);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除文件夹使用rmdir函数，文件夹必须为空，如果不为空或者没有权限则会提示失败。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rmdir($dir);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果文件夹中存在文件，可以先循环删除目录中的所有文件，然后再删除该目录，循环删除可以使用glob函数遍历所有文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;foreach (glob(&amp;quot;*&amp;quot;) as $filename) {
   unlink($filename);
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;cookie简介&lt;/p&gt;
&lt;p&gt;Cookie是存储在客户端浏览器中的数据，我们通过Cookie来跟踪与存储用户数据。一般情况下，Cookie通过HTTP headers从服务端返回到客户端。多数web程序都支持Cookie的操作，因为Cookie是存在于HTTP的标头之中，
    
    </summary>
    
    
      <category term="cookie session" scheme="http://xwzmsdqbjzyyg.github.io/tags/cookie-session/"/>
    
  </entry>
  
  <entry>
    <title>PHP中的哈希表结构</title>
    <link href="http://xwzmsdqbjzyyg.github.io/2016/06/08/array-02/"/>
    <id>http://xwzmsdqbjzyyg.github.io/2016/06/08/array-02/</id>
    <published>2016-06-08T08:01:54.000Z</published>
    <updated>2016-06-08T08:15:24.877Z</updated>
    
    <content type="html">&lt;p&gt;什么叫哈希表？&lt;/p&gt;
&lt;p&gt;散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。–维基百科&lt;/p&gt;
&lt;p&gt;…&lt;br&gt;从定义看哈希表最关键的几个方面&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过一关键码访问（关键码的确定，哈希函数）&lt;/li&gt;
&lt;li&gt;映射到数据结构中（哈希表本身的存储结构）&lt;/li&gt;
&lt;li&gt;映射的处理（冲突或者碰撞检测和处理函数）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于PHP的哈希我们也从上面三个方面进行分析。一般来说对于整形索引进行哈希我们很容易想到的是取模运算，比如array(1=&amp;gt;’a’, 2=&amp;gt;’b’, 3=&amp;gt;’c’)，这类我们可以使用index%3来哈希，不过PHP数组的下标还有更灵活的array(‘a’=’c’, ‘b’=&amp;gt;’d’), 此时选择什么哈希函数？答案是DJBX33A算法（DJBX33A算法，也就是time33算法，是APR默认哈希算法，php, apache, perl, bsddb也都使用time33哈希。对于33这个数，DJB注释中是说，1到256之间的所有奇数，都能达到一个可接受的哈希分布，平均分布大概是86%。而其中33，17，31，63，127，129这几个数在面对大量的哈希运算时有一个更大的优势，就是这些数字能将乘法用位运算配合加减法替换，这样运算速度会更高。gcc编译器开启优化后会自动将乘法转换为位运算。）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static inline ulong zend_inline_hash_func(char *arKey, uint nKeyLength){         
    register ulong hash = 5381;     /* variant with the hash unrolled eight times */      
    for (; nKeyLength &amp;gt;= 8; nKeyLength -= 8） {          
        hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++;          
        hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++;          
        hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++;          
        hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++;          
        hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++;          
        hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++;          
        hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++;          
        hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++;      
    }  
    switch (nKeyLength) {          
        case 7: hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++; /* fallthrough... */          
        case 6: hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++; /* fallthrough... */          
        case 5: hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++; /* fallthrough... */          
        case 4: hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++; /* fallthrough... */          
        case 3: hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++; /* fallthrough... */          
        case 2: hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++; /* fallthrough... */          
        case 1: hash = ((hash &amp;lt;&amp;lt; 5) + hash) + *arKey++; break;          
        case 0: break;  
        EMPTY_SWITCH_DEFAULT_CASE()      
    }  
    return hash;  
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有了哈希函数之后那么哈希表本身的存储结构如何？这里需要说明两种PHP底层的数据结构HashTable 和 Bucket&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct _hashtable {  
    uint nTableSize;  
    uint nTableMask;  
    uint nNumOfElements;  
    ulong nNextFreeElement;  
    Bucket *pInternalPointer;  
    Bucket *pListHead;  
    Bucket *pListTail;  
    Bucket **arBuckets;  
    dtor_func_t pDestructor;  
    zend_bool persistent;  
    unsigned char nApplyCount;  
    zend_bool bApplyProtection;  
#if ZEND_DEBUG  
    int inconsistent;  
#endif  
} HashTable  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;……..&lt;/p&gt;
&lt;p&gt;上述结构体定义了PHP底层的存储结构，逐个字段做个解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;nNumOfElements 是PHP数组中实际存储元素的个数，我们使用count,sizeof计算的就是获取的这个值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;nTableSize 顾名思义这个是整个哈希表分配的大小（在内部实现的C中分配的数组大小，PHP是动态的但到底层数组是有大小的是静态的）,他的大小有一个固定的申请算法，一般是最接近并且大于当前这个数值的2的乘方，描述的可能有点模糊，举个例子来看，如果PHP数组存储32个整形数据，那么底层申请的nTableSize应该等于32个元素,如果33呢，那么取最近且大于这个数的一个数64，那么分配的大小是64个元素。这样分配的原因是为了能分配足够的内存同样又不会浪费太多的内存。基于哈希的效率考虑，太小那么势必造成哈希之后太多的碰撞查找，如果分配太大那么必然浪费太多内存，这样分配经过实践证明相对在空间和时间上可以获得一个平衡。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;nTableMask 哈希表的掩码数值等于nTableSize-1,他的作用是什么？用来纠正通过上面DBJ算法计算的哈希值在当前nTableSize大小的哈希表中的正确的索引值。比如”foo”通过固定算法之后得出的哈希值是193491849，如果表的大小为64，很明显已经超过了最大索引值，这时候就需要运用哈希表的掩码对其进行矫正实际采用的方法就是与掩码进行位运与运算&lt;/p&gt;
&lt;p&gt;hash  |   193491849 |   0b1011100010000111001110001001&lt;br&gt;&amp;amp; mask  | &amp;amp;        63 | &amp;amp; 0b0000000000000000000000111111&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt; = index | =         9 | = 0b0000000000000000000000001001&lt;/p&gt;
&lt;p&gt;这样做是为了把哈希值大的一样映射到nTalbeSize空间内&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;nNextFreeElement 下一个空闲的元素空间，当我们申请一个空下标元素的时候就需要用到此项，比如$ret[] = ‘apple’&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;pInternalPointer 存储了内部当前执行的元素的指针，当我们使用一些内部循环函数的时候会用到这个指针比如reset(), current(), prev(), next(), foreach(), end()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;pListHead和pListTail则具体指向了该哈希表的第一个和最后一个元素，对应就是数组的起始和结束元素。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;7.arBuckets 这个就是实际存储的C的内部数组，具体的结构后面还会详细讨论。这里记录的是一个指向指针的指针Bucket **。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;pDestructor 是一个析构函数，当某个值被从哈希表删除的时候会触发此函数。他还有一个主要作用是用于变量的GC回收。在PHP里面GC是通过引用计数实现的，当一个变量的引用计数变为0，就会被PHP的GC回收&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;persistent 定义了hashtable是否能在多次request中获得持久存在&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;nApplyCount 和 bApplyProtection 是用来防止无限递归的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;inconsistent 是在调试模式下捕获对HT不正确的使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来讨论HT中真正的数据存储单元Buckets结构:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct bucket {  
    ulong h;  
    uint nKeyLength;  
    void *pData;  
    void *pDataPtr;  
    struct bucket *pListNext;  
    struct bucket *pListLast;  
    struct bucket *pNext;  
    struct bucket *pLast;  
    const char *arKey;  
} Bucket;  
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;h是一个哈希值 未经过掩码矫正的哈希DBJ算出来的原始值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;arKey,用来记录作为哈希计算的字符串, nKeyLength是哈希字符串的长度，对于整形键值是用不到这两项的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;pData以及pDataPtr是实际存储数据的指针，在PHP里面他们通常是指向一个zval结构（该结构广泛被PHP用来内部存储各种变量以及对象）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;pListNext, pListLast 指定了整个数组的顺序, PHP中的遍历就是通过哈希结构体中的pListHead bucket依次遍历pNext直到数组结束。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;pNext和pLast 这两个指针是用来解决哈希冲突的，这个在下面哈希冲突中详细介绍，在PHP的哈希表冲突的处理采用的是拉链法也就是在每个可能冲突的键值位置拉出一个链表来存储对应的键值数据(哈希冲突还有什么解决方法？寻址法不过在PHP中并是通过这个方式实现的)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于哈希冲突，PHP的实现是通过拉链法实现的，当键值被哈希到同一个槽位（bucket）就是发生了冲突，这时候会从bucket拉出一个链表把冲突的元素顺序链接起来。pListNext,pListLast就是实现这个拉链的结构的&lt;/p&gt;
&lt;p&gt;至此PHP的哈希的基本结构介绍完毕，实现是非常complex的，但对比灵活无比的PHP数组这点点复杂性值，太TM值了。&lt;/p&gt;
&lt;p&gt;关于那两队对指针，国外有网站上搞错了，这里把检测哈希冲突的PHP函数贴出来，pNext指针的作用就一目了然了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ZEND_API int zend_hash_exists(const HashTable *ht, const char *arKey, uint nKeyLength)  
{  
    ulong h;  
    uint nIndex;  
    Bucket *p;  

    IS_CONSISTENT(ht);  

    h = zend_inline_hash_func(arKey, nKeyLength);  
    nIndex = h &amp;amp; ht-&amp;gt;nTableMask;  

    p = ht-&amp;gt;arBuckets[nIndex];  
    while (p != NULL) {  
        if (p-&amp;gt;arKey == arKey ||  
            ((p-&amp;gt;h == h) &amp;amp;&amp;amp; (p-&amp;gt;nKeyLength == nKeyLength) &amp;amp;&amp;amp; !memcmp(p-&amp;gt;arKey, arKey, nKeyLength))) {  
                return 1;  
        }  
        p = p-&amp;gt;pNext;  
    }  
    return 0;  
}  
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;什么叫哈希表？&lt;/p&gt;
&lt;p&gt;散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。–维基百科&lt;
    
    </summary>
    
    
      <category term="数组" scheme="http://xwzmsdqbjzyyg.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>PHP 数组浅析</title>
    <link href="http://xwzmsdqbjzyyg.github.io/2016/06/08/array-01/"/>
    <id>http://xwzmsdqbjzyyg.github.io/2016/06/08/array-01/</id>
    <published>2016-06-08T07:06:04.000Z</published>
    <updated>2016-06-08T07:22:23.084Z</updated>
    
    <content type="html">&lt;p&gt;一、概要&lt;br&gt;    简单介绍及基本使用&lt;br&gt;    php数组 常用标准库函数使用&lt;br&gt;    php数组模拟常见数据结构&lt;br&gt;    php数组使用须知与注意点&lt;br&gt;    FAQ&lt;br&gt;二、简单介绍及基本使用&lt;br&gt;    PHP 中的数组实际上是一个有序映射。映射是一种把 values 关联到 keys 的类型。&lt;br&gt;    通过&amp;lt;?php $arr = array(1, 2, 3, 4); 便定义了一个普通数组&lt;br&gt;    我们还可以定义关联数组&lt;/p&gt;
&lt;p&gt;&amp;lt;?php  $arr = array(‘a’ =&amp;gt; 1, ‘z’ =&amp;gt; 100); &amp;gt;&lt;br&gt;  ……&lt;br&gt;    如果php版本 &amp;gt;= 5.4 , 我们可以使用更为简洁的方式定义数组&lt;/p&gt;
&lt;p&gt;&amp;lt;?php&lt;br&gt;$arr = [1, 2, 3, 4];&lt;br&gt;$arr = [‘a’ =&amp;gt; 1, ‘z’ =&amp;gt; 100];&lt;br&gt;    php 数组很强大， 可以定义混合类型数组&lt;/p&gt;
&lt;p&gt;&amp;lt;?php&lt;br&gt;$arr = [1, ‘hello’ =&amp;gt; ‘11’, ‘arr’ =&amp;gt; [1, ‘a’=&amp;gt;’b’]];&lt;br&gt;……&lt;br&gt;    关于数组的访问操作，可以通过[index] 访问：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php&lt;br&gt;$arr = [1, ‘hello’ =&amp;gt; ‘11’, ‘arr’ =&amp;gt; [1, ‘a’=&amp;gt;’b’]];&lt;br&gt;var_dump($arr[0]); // 1&lt;br&gt;var_dump($arr[‘arr’]); // [1, ‘a’ =&amp;gt; ‘b’]&lt;br&gt;……&lt;br&gt;    也可以通过[] 修改数组元素的值&lt;/p&gt;
&lt;p&gt;&amp;lt;?php&lt;br&gt;$arr = [1, ‘hello’ =&amp;gt; ‘11’, ‘arr’ =&amp;gt; [1, ‘a’=&amp;gt;’b’]];&lt;br&gt;$arr[0] = ‘test’;&lt;br&gt;var_dump($arr);&lt;br&gt;……&lt;br&gt;    你也可以在初始化数组继续添加数组元素&lt;/p&gt;
&lt;p&gt;&amp;lt;?php&lt;br&gt;$arr = [1, 2, 3, 4];&lt;br&gt;//追加元素&lt;br&gt;$arr[] = ‘a’;&lt;br&gt;// 添加 key, value&lt;br&gt;$arr[‘test’] = ‘b’;&lt;br&gt;……&lt;br&gt;    当然，删除数组元素的操作必须支持&lt;/p&gt;
&lt;p&gt;&amp;lt;?php&lt;br&gt;$arr = [1, ‘hello’ =&amp;gt; ‘11’, ‘arr’ =&amp;gt; [1, ‘a’=&amp;gt;’b’]];&lt;br&gt;unset($arr[‘hello’]);&lt;br&gt;var_dump($arr[‘hello’]);  // null&lt;br&gt;……&lt;br&gt;    开发中经常需要遍历数组, 可使用 foreach ：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php&lt;br&gt;$arr = [1, ‘hello’ =&amp;gt; ‘11’, ‘arr’ =&amp;gt; [1, ‘a’=&amp;gt;’b’]];&lt;br&gt;foreach($arr as $key =&amp;gt; $value) {&lt;br&gt;    var_dump($key . ‘ =&amp;gt; ‘ . $value);&lt;br&gt;}&lt;br&gt;……&lt;br&gt;更多数组遍历的方法请参考php-数组遍历&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组之间的比较，数组无法比较大小， 但可以根据一定条件判断是否相等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;?php&lt;br&gt;// $a == $b 相等 如果 $a 和 $b 具有相同的键／值对则为 TRUE。&lt;br&gt;// $a === $b 全等 如果 $a 和 $b 具有相同的键／值对并且顺序和类型都相同则为 TRUE。&lt;/p&gt;
&lt;p&gt;$a = [1, 2];&lt;br&gt;$b = [‘1’ =&amp;gt; 2, 0 =&amp;gt; 1];&lt;/p&gt;
&lt;p&gt;var_dump($a == $b); // true&lt;br&gt;var_dump($a === $b); // false&lt;/p&gt;
&lt;p&gt;三、实用的数组工具函数&lt;br&gt;掌握了数组的基本操作(定义使用，增删改查， 遍历) 之后，你就可以在开发中使用数组， 但只有这些操作是远远不够的，为了满足复杂多变的开发场景对数组操作的需求，PHP 提供了功能强大的一套 Array 操作的函数&lt;br&gt;……&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取数组长度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;?php&lt;br&gt;$arr = [1, 2, 3];&lt;br&gt;var_dump(count($arr)); // 3&lt;br&gt;……&lt;br&gt;    希望判断一个变量是否是数组，可以通过 is_array()：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php&lt;br&gt;$arr = [1, 2, 3];&lt;br&gt;$notArr = ‘111’;&lt;br&gt;var_dump(is_array($arr)); // true&lt;br&gt;var_dump(is_array($notArr)); // false&lt;br&gt;……&lt;br&gt;    更具key 或者 value， 判断元素 是否在数组中&lt;/p&gt;
&lt;p&gt;// 判断key 是否在数组中&lt;br&gt;$arr = [‘a’ =&amp;gt; 2, 4];&lt;br&gt;var_dump(isset($arr[‘a’])); // true&lt;br&gt;var_dump(array_key_exists(‘a’, $arr)); // true&lt;/p&gt;
&lt;p&gt;// 判断 value 是否在数组中&lt;br&gt;in_array(5, $arr);  // false&lt;br&gt;    获取数组所有键(keys)&lt;/p&gt;
&lt;p&gt;&amp;lt;?php&lt;br&gt;$arr = [‘a’ =&amp;gt; 2, 4];&lt;br&gt;$keys = array_keys($arr); // [‘a’, 1]&lt;br&gt;……&lt;br&gt;    获取数组的所有值 (values)&lt;/p&gt;
&lt;p&gt;&amp;lt;?php&lt;br&gt;$arr = [‘a’ =&amp;gt; 2, 4];&lt;br&gt;$values = array_values($arr); // [2, 4]&lt;br&gt;……&lt;br&gt;    统计数组各个元素值出现的次数 可以使用 array_count_values：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php&lt;br&gt;$arr = [1, 3, 2, ‘a’ =&amp;gt; 1, ‘b’ =&amp;gt; 2];&lt;br&gt;var_dump(array_count_values($arr));&lt;br&gt;/&lt;em&gt;&lt;br&gt;array(3) {&lt;br&gt;  [1]=&amp;gt;&lt;br&gt;  int(2)&lt;br&gt;  [3]=&amp;gt;&lt;br&gt;  int(1)&lt;br&gt;  [2]=&amp;gt;&lt;br&gt;  int(2)&lt;br&gt;}
&lt;/em&gt;/&lt;/p&gt;
&lt;p&gt;数组与数组之间的操作：数组可以看做一个集合， 集合间的操作(交集，差集，并集， 补集， 比较等) php 也提供相应的方法实现&lt;br&gt;……&lt;br&gt;    数组的合并&lt;br&gt;&amp;lt;?php&lt;br&gt;$arr1 = [‘a’ =&amp;gt; 1, 2, ‘b’ =&amp;gt; 3];&lt;br&gt;$arr2 = [‘b’ =&amp;gt; 5, 2];&lt;br&gt;var_dump( array_merge($arr1, $arr2) );&lt;br&gt;/*&lt;br&gt;array(4) {&lt;br&gt;  [“a”]=&amp;gt;&lt;br&gt;  int(1)&lt;br&gt;  [0]=&amp;gt;&lt;br&gt;  int(2)&lt;br&gt;  [“b”]=&amp;gt;&lt;br&gt;  int(5)&lt;br&gt;  [1]=&amp;gt;&lt;br&gt;  int(2)&lt;br&gt;}&lt;/p&gt;
&lt;p&gt;// 你也可以使用 + 操作符, 请注意两种方法结果的差别&lt;br&gt;var_dump($arr1 + $arr2);&lt;br&gt;*/&lt;br&gt;    如果是需要计算两个或跟多数组value的交集, 可使用 array_intersect&lt;/p&gt;
&lt;p&gt;&amp;lt;?php&lt;br&gt;$arr1 = [1, 2, 3];&lt;br&gt;$arr2 = [5, 2];&lt;br&gt;var_dump( array_intersect($arr1, $arr2) );  // [2]&lt;br&gt;……&lt;br&gt;    数组的差集 (按值value 和 按key)&lt;/p&gt;
&lt;p&gt;&amp;lt;?php&lt;br&gt;$a = [1, 2];&lt;br&gt;$b = [‘1’ =&amp;gt; 2, 0 =&amp;gt; 1, 4];&lt;/p&gt;
&lt;p&gt;//array_diff 按照索引 和 值 比较差异&lt;br&gt;var_dump(array_diff($a, $b));&lt;/p&gt;
&lt;p&gt;// array_diff_key() 函数用于比较两个（或更多个）数组的键名 ，并返回差集&lt;br&gt;var_dump(array_diff_key($a, $b));&lt;br&gt;……&lt;br&gt;    如果需要获取子数组， 可以通过 array_slice 产生类似 python 切片的效果&lt;/p&gt;
&lt;p&gt;&amp;lt;?php&lt;br&gt;$arr = [1, 2, 3, 4, 5, 6, 7, 8];&lt;br&gt;// 从第3个元素开始, 直到结束&lt;br&gt;var_dump(array_slice($arr, 2));&lt;/p&gt;
&lt;p&gt;// 从第3个元素开始, 长度为4&lt;br&gt;var_dump(array_slice($arr, 2, 4));&lt;/p&gt;
&lt;p&gt;// 从第3个元素开始，到倒数第3个元素&lt;br&gt;var_dump(array_slice($arr, 2, -2));&lt;/p&gt;
&lt;p&gt;// 注意 索引的差别&lt;br&gt;var_dump(array_slice($arr, 2, -2, true));&lt;br&gt;……&lt;br&gt;    关于数组的排序操作，也是比较常见的开发需求，需要注意的是：php排序函数都是直接作用于数组本身， 而不是返回一个新的有序的数组。, 以下代码提供几种常见的场景， 更多请参考php对数组进行排序：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php&lt;/p&gt;
&lt;p&gt;// 按照值(value)升序排序, 索引更新&lt;br&gt;$arr = [6,’a’=&amp;gt;2, 3, 4, 6, -1, 7, 8];&lt;br&gt;sort($arr);&lt;br&gt;var_dump($arr);&lt;/p&gt;
&lt;p&gt;// 按照值(value)升序排序, 索引保持&lt;br&gt;$arr = [6,’a’=&amp;gt;2, 3, 4, 6, -1, 7, 8];&lt;br&gt;asort($arr);&lt;br&gt;var_dump($arr);&lt;/p&gt;
&lt;p&gt;// 按照值(value)降序排序, 索引保持&lt;br&gt;$arr = [6,’a’=&amp;gt;2, 3, 4, 6, -1, 7, 8];&lt;br&gt;arsort($arr);&lt;br&gt;var_dump($arr);&lt;/p&gt;
&lt;p&gt;// 按照 键(key)进行升序排序 , 索引保持&lt;br&gt;$arr = [‘a’ =&amp;gt; 10, ‘c’ =&amp;gt; 1, ‘b’ =&amp;gt; 12];&lt;br&gt;ksort($arr);&lt;br&gt;var_dump($arr);&lt;/p&gt;
&lt;p&gt;// 按照 键(key)进行降序排序 , 索引保持&lt;br&gt;$arr = [‘a’ =&amp;gt; 10, ‘c’ =&amp;gt; 1, ‘b’ =&amp;gt; 12];&lt;br&gt;krsort($arr);&lt;br&gt;var_dump($arr);&lt;/p&gt;
&lt;p&gt;// 用户自定义排序, 根据值(value) , 索引更新&lt;br&gt;// 请注意：对于自定义的比较函数，&lt;br&gt;// 在第一个参数小于，等于或大于第二个参数时，&lt;br&gt;// 该比较函数必须相应地返回一个小于，等于或大于 0 的整数。&lt;br&gt;function cmp($val1, $val2)&lt;br&gt;{&lt;br&gt;    if($val1 &amp;gt; $val2) {&lt;br&gt;        return 1;&lt;br&gt;    } elseif ($val1 == $val2) {&lt;br&gt;        return 0;&lt;br&gt;    } else {&lt;br&gt;        return -1;&lt;br&gt;    }&lt;br&gt;}&lt;/p&gt;
&lt;p&gt;$arr = [&lt;br&gt;    ‘a’ =&amp;gt; 1,&lt;br&gt;    ‘A’ =&amp;gt; 3,&lt;br&gt;    ‘B’ =&amp;gt; 2,&lt;br&gt;];&lt;/p&gt;
&lt;p&gt;usort($arr, cmp);&lt;br&gt;var_dump($arr);&lt;/p&gt;
&lt;p&gt;// 根据key 自定义排序规则，请使用 uksort(), 用法同usort()&lt;br&gt;……&lt;br&gt;    关于数组与字符串之间的操作一般有切割字符串，合并数组元素转为字符串两种操作，可以借助explode与implode实现&lt;br&gt;&amp;lt;?php&lt;br&gt;var_dump(explode(‘,’, “a,a,a,a,a,a”)); // 以,为分割符将字符串”a,a,a,a,a,a” 切割成数组&lt;/p&gt;
&lt;p&gt;var_dump(implode(‘-‘, [1, 2, 3, 4, 5])); //以 - 为 拼接符 将 数组[1, 2, 3, 4, 5] 拼接成字符串&lt;/p&gt;
&lt;p&gt;关于php 更多数组相关的函数， 可以参考 官方文档php数组函数列表&lt;br&gt;四、数组模拟常见数据结构&lt;/p&gt;
&lt;p&gt;php 数组可以模拟常见的数据结构，最显而易见的便是 映射表 和 字典， 这里简单介绍php数组对栈和队列的模拟。&lt;br&gt;    模拟栈(FILO)&lt;/p&gt;
&lt;p&gt;&amp;lt;?php&lt;br&gt;$stack = [1, 2, 3, 4];&lt;/p&gt;
&lt;p&gt;//入栈&lt;br&gt;array_push($stack, -1);&lt;br&gt;var_dump($stack); // [1, 2, 3, 4, -1]&lt;/p&gt;
&lt;p&gt;//出栈&lt;br&gt;$e = array_pop($stack);&lt;br&gt;var_dump($e); // -1&lt;br&gt;var_dump($stack);  // [1, 2, 3, 4]&lt;br&gt;    模拟队列 (FIFO)&lt;/p&gt;
&lt;p&gt;&amp;lt;?php&lt;br&gt;$queue = [];&lt;/p&gt;
&lt;p&gt;//入队列&lt;br&gt;array_unshift($queue, 1);&lt;br&gt;array_unshift($queue, 2);&lt;br&gt;array_unshift($queue, 3);&lt;br&gt;array_unshift($queue, 4);&lt;/p&gt;
&lt;p&gt;//出队列&lt;br&gt;$e = array_pop($queue);&lt;br&gt;var_dump($e); // 1&lt;br&gt;$e = array_pop($queue);&lt;br&gt;var_dump($e); // 2&lt;br&gt;$e = array_pop($queue);&lt;br&gt;var_dump($e); // 3&lt;br&gt;$e = array_pop($queue);&lt;br&gt;var_dump($e); // 4&lt;/p&gt;
&lt;p&gt;五、php数组使用须知与注意点&lt;br&gt;    php 数组 key值 会存在以下强制转换&lt;br&gt;        包含有合法整型值的字符串会被转换为整型。例如键名 “8” 实际会被储存为 8。但是 “08” 则不会强制转换，因为其不是一个合法的十进制数值。&lt;br&gt;        浮点数也会被转换为整型，意味着其小数部分会被舍去。例如键名 8.7 实际会被储存为 8。&lt;br&gt;        布尔值也会被转换成整型。即键名 true 实际会被储存为 1 而键名 false 会被储存为 0。&lt;br&gt;        Null 会被转换为空字符串，即键名 null 实际会被储存为 “”。&lt;br&gt;        数组和对象不能被用为键名。坚持这么做会导致警告：Illegal offset type。&lt;/p&gt;
&lt;p&gt;因此以下代码可能导致意外的结果，请注意以下代码的输出：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php&lt;/p&gt;
&lt;p&gt;$arr = [1, 2, ‘8’ =&amp;gt; 3];&lt;/p&gt;
&lt;p&gt;$arr[false] = -20;&lt;br&gt;var_dump($arr); // [-20, 2, ‘8’ =&amp;gt; 3]&lt;/p&gt;
&lt;p&gt;$arr[8] = 20;&lt;br&gt;var_dump($arr); // [-20, 2, 8 =&amp;gt; 20]&lt;/p&gt;
&lt;p&gt;$arr[8.7] = 15;&lt;br&gt;var_dump($arr); // [-20, 2, 8 =&amp;gt; 15]&lt;/p&gt;
&lt;p&gt;$arr[“8.7”] = 10;&lt;br&gt;var_dump($arr); // [-20, 2, 8 =&amp;gt; 10]&lt;/p&gt;
&lt;p&gt;$arr[$val]  = 5; // 注意$val之前为声明，因此默认值为null, 数组key为null时会被转为””空串&lt;br&gt;var_dump($arr); // [-20, 2, 8 =&amp;gt; 10, “” =&amp;gt; 5]&lt;/p&gt;
&lt;p&gt;$arr[bar] = 6; // 标识符被转化为 ‘bar’&lt;br&gt;var_dump($arr); // [-20, 2, 8 =&amp;gt; 10, “” =&amp;gt; 5, ‘bar’ =&amp;gt; 6]&lt;/p&gt;
&lt;p&gt;……&lt;br&gt;    关于php数组的类型转换&lt;br&gt;    php数组可以将其他一切类型转为数组，转化的效果请参考一下代码，重点观察对 null 和 object对象的转化：&lt;/p&gt;
&lt;p&gt;&amp;lt;?php&lt;/p&gt;
&lt;p&gt;$var = true;&lt;br&gt;var_dump((array)$var);&lt;br&gt;/&lt;em&gt; array(1) {&lt;br&gt;  [0]=&amp;gt;&lt;br&gt;  bool(true)&lt;br&gt;}&lt;/em&gt;/&lt;/p&gt;
&lt;p&gt;$var = 1;&lt;br&gt;var_dump((array)$var);&lt;br&gt;/&lt;em&gt; array(1) {&lt;br&gt;  [0]=&amp;gt;&lt;br&gt;  int(1)&lt;br&gt;}&lt;/em&gt;/&lt;/p&gt;
&lt;p&gt;$var = 1.1;&lt;br&gt;var_dump((array)$var);&lt;br&gt;/&lt;em&gt; array(1) {&lt;br&gt;  [0]=&amp;gt;&lt;br&gt;  float(1.1)&lt;br&gt;}&lt;/em&gt;/&lt;/p&gt;
&lt;p&gt;$var = “111”;&lt;br&gt;var_dump((array)$var);&lt;br&gt;/&lt;em&gt; array(1) {&lt;br&gt;  [0]=&amp;gt;&lt;br&gt;  string(3) “111”&lt;br&gt;}&lt;/em&gt;/&lt;/p&gt;
&lt;p&gt;$var = null;&lt;br&gt;var_dump((array)$var);  // 返回空数组&lt;br&gt;/&lt;em&gt; array(0) {&lt;br&gt;} &lt;/em&gt;/&lt;/p&gt;
&lt;p&gt;class Cls { public $a = 1; protected $b = 2; private $c = 3; }&lt;br&gt;var_dump((array)(new Cls)); // 可见性不同 key值格式有所不同&lt;br&gt;/&lt;em&gt; array(3) {&lt;br&gt;  [“a”]=&amp;gt;&lt;br&gt;  int(1)&lt;br&gt;  [“&lt;/em&gt;b”]=&amp;gt;&lt;br&gt;  int(2)&lt;br&gt;  [“Clsc”]=&amp;gt;&lt;br&gt;  int(3)&lt;br&gt;} */&lt;/p&gt;
&lt;p&gt;关于PHP类型转换的了解，请参考PHP-类型转换的判别&lt;br&gt;六、FAQ&lt;br&gt;……&lt;br&gt;    如何添加数组元素更为高效? array_push($arr, key, value) or $arr[key] = value ? 答： 后者更为高效， 更多细节请参考官方资料&lt;br&gt;    isset or array_key_exists() ? 答：&lt;br&gt;        对于存在key的数组，如果 对应的value = null ， isset($arr[key]) 会返回 false；而对于array_key_exists 只要对应key存在就会返回true；&lt;br&gt;        然而在效率方面，isset 效率 高于array_key_eixsts&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一、概要&lt;br&gt;    简单介绍及基本使用&lt;br&gt;    php数组 常用标准库函数使用&lt;br&gt;    php数组模拟常见数据结构&lt;br&gt;    php数组使用须知与注意点&lt;br&gt;    FAQ&lt;br&gt;二、简单介绍及基本使用&lt;br&gt;    PHP 中的数组实际上是一个有序映
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>配置lnmp</title>
    <link href="http://xwzmsdqbjzyyg.github.io/2016/06/01/lnmp-01/"/>
    <id>http://xwzmsdqbjzyyg.github.io/2016/06/01/lnmp-01/</id>
    <published>2016-06-01T08:12:56.000Z</published>
    <updated>2016-08-29T05:30:38.274Z</updated>
    
    <content type="html">&lt;p&gt;===================&lt;br&gt;准备篇：&lt;/p&gt;
&lt;p&gt;1、配置防火墙，开启80端口、3306端口&lt;br&gt;vi /etc/sysconfig/iptables&lt;br&gt;-A INPUT -m state –state NEW -m tcp -p tcp –dport 80 -j ACCEPT（允许80端口通过防火墙）&lt;br&gt;-A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT（允许3306端口通过防火墙）&lt;br&gt;特别提示：很多网友把这两条规则添加到防火墙配置的最后一行，导致防火墙启动失败，正确的应该是添加到默认的22端口这条规则的下面&lt;br&gt;添加好之后防火墙规则如下所示：&lt;/p&gt;
&lt;p&gt;#########################################################&lt;/p&gt;
&lt;h1 id=&quot;Firewall-configuration-written-by-system-config-firewall&quot;&gt;&lt;a href=&quot;#Firewall-configuration-written-by-system-config-firewall&quot; class=&quot;headerlink&quot; title=&quot;Firewall configuration written by system-config-firewall&quot;&gt;&lt;/a&gt;Firewall configuration written by system-config-firewall&lt;/h1&gt;&lt;h1 id=&quot;Manual-customization-of-this-file-is-not-recommended&quot;&gt;&lt;a href=&quot;#Manual-customization-of-this-file-is-not-recommended&quot; class=&quot;headerlink&quot; title=&quot;Manual customization of this file is not recommended.&quot;&gt;&lt;/a&gt;Manual customization of this file is not recommended.&lt;/h1&gt;&lt;p&gt;*filter&lt;br&gt;:INPUT ACCEPT [0:0]&lt;br&gt;:FORWARD ACCEPT [0:0]&lt;br&gt;:OUTPUT ACCEPT [0:0]&lt;br&gt;-A INPUT -m state –state ESTABLISHED,RELATED -j ACCEPT&lt;br&gt;-A INPUT -p icmp -j ACCEPT&lt;br&gt;-A INPUT -i lo -j ACCEPT&lt;br&gt;-A INPUT -m state –state NEW -m tcp -p tcp –dport 22 -j ACCEPT&lt;br&gt;-A INPUT -mstate –state NEW -m tcp -p tcp –dport 80 -j ACCEPT&lt;br&gt;-A INPUT -mstate –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT&lt;br&gt;-A INPUT -j REJECT –reject-with icmp-host-prohibited&lt;br&gt;-A FORWARD -j REJECT –reject-with icmp-host-prohibited&lt;br&gt;COMMIT&lt;/p&gt;
&lt;p&gt;#########################################################&lt;br&gt;/etc/init.d/iptables restart  #最后重启防火墙使配置生效&lt;/p&gt;
&lt;p&gt;2、关闭SELINUX&lt;br&gt;vi /etc/selinux/config&lt;/p&gt;
&lt;p&gt;#SELINUX=enforcing       #注释掉&lt;/p&gt;
&lt;p&gt;#SELINUXTYPE=targeted    #注释掉&lt;br&gt;SELINUX=disabled         #增加&lt;/p&gt;
&lt;p&gt;:wq  保存，关闭&lt;br&gt;shutdown -r now   #重启系统&lt;/p&gt;
&lt;p&gt;3、配置CentOS 6.2第三方yum源（CentOS默认的标准源里没有nginx软件包）&lt;br&gt;yum install wget    #安装下载工具wget&lt;br&gt;wget &lt;a href=&quot;http://www.atomicorp.com/installers/atomic&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.atomicorp.com/installers/atomic&lt;/a&gt;  #下载atomic yum源&lt;br&gt;sh ./atomic   #安装&lt;br&gt;yum check-update  #更新yum软件包&lt;/p&gt;
&lt;p&gt;#############################################################################&lt;br&gt;安装篇：&lt;/p&gt;
&lt;p&gt;一、安装nginx&lt;br&gt;yum install nginx      #安装nginx，根据提示，输入Y安装即可成功安装&lt;br&gt;service nginx start    #启动&lt;br&gt;chkconfig nginx on    #设为开机启动&lt;br&gt;/etc/init.d/nginx  restart  #重启&lt;br&gt;rm -rf /usr/share/nginx/html/*  #删除ngin默认测试页&lt;/p&gt;
&lt;p&gt;二、安装MySQL&lt;br&gt;1、安装mysql&lt;/p&gt;
&lt;p&gt; yum install mysql mysql-server   #询问是否要安装，输入Y即可自动安装,直到安装完成&lt;br&gt;/etc/init.d/mysqld start   #启动MySQL&lt;br&gt;chkconfig mysqld on   #设为开机启动&lt;br&gt;cp /usr/share/mysql/my-medium.cnf   /etc/my.cnf  #拷贝配置文件（注意：如果/etc目录下面默认有一个my.cnf，直接覆盖即可）&lt;br&gt;shutdown -r now  #重启系统&lt;/p&gt;
&lt;p&gt;2、为root账户设置密码&lt;br&gt;mysql_secure_installation&lt;/p&gt;
&lt;p&gt;回车，根据提示输入Y&lt;/p&gt;
&lt;p&gt;输入2次密码，回车&lt;/p&gt;
&lt;p&gt;根据提示一路输入Y&lt;/p&gt;
&lt;p&gt;最后出现：Thanks for using MySQL!&lt;/p&gt;
&lt;p&gt;MySql密码设置完成，重新启动 MySQL：&lt;br&gt;/etc/init.d/mysqld stop   #停止&lt;br&gt;/etc/init.d/mysqld start  #启动&lt;br&gt;service mysqld restart    #重启&lt;/p&gt;
&lt;p&gt;三、安装PHP&lt;br&gt;1、安装PHP&lt;br&gt;yum install php   #根据提示输入Y直到安装完成&lt;br&gt;2、安装PHP组件，使PHP支持 MySQL、PHP支持FastCGI模式&lt;br&gt;yum install php-mysql php-gd libjpeg* php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-mcrypt php-bcmath php-mhash libmcrypt libmcrypt-devel php-fpm          #根据提示输入Y回车&lt;br&gt;/etc/init.d/mysqld restart  #重启MySql&lt;br&gt;/etc/init.d/nginx  restart  #重启nginx&lt;br&gt;/etc/rc.d/init.d/php-fpm start  #启动php-fpm&lt;br&gt;chkconfig php-fpm on  #设置开机启动&lt;/p&gt;
&lt;p&gt;#############################################################################&lt;br&gt;配置篇&lt;/p&gt;
&lt;p&gt;一、配置nginx支持php&lt;br&gt;cp /etc/nginx/nginx.conf  /etc/nginx/nginx.confbak    #备份原有配置文件&lt;br&gt;vi /etc/nginx/nginx.conf  #编辑&lt;br&gt;user  nginx  nginx;  #修改nginx运行账号为：nginx组的nginx用户&lt;/p&gt;
&lt;p&gt;:wq!    #保存退出&lt;/p&gt;
&lt;p&gt;cp /etc/nginx/conf.d/default.conf /etc/nginx/conf.d/default.confbak   #备份原有配置文件&lt;br&gt;vi /etc/nginx/conf.d/default.conf   #编辑&lt;/p&gt;
&lt;p&gt;index index.php index.html index.htm;   #增加index.php&lt;/p&gt;
&lt;h1 id=&quot;pass-the-PHPscripts-to-FastCGI-server-listening-on-127-0-0-1-9000&quot;&gt;&lt;a href=&quot;#pass-the-PHPscripts-to-FastCGI-server-listening-on-127-0-0-1-9000&quot; class=&quot;headerlink&quot; title=&quot;pass the PHPscripts to FastCGI server listening on 127.0.0.1:9000&quot;&gt;&lt;/a&gt;pass the PHPscripts to FastCGI server listening on 127.0.0.1:9000&lt;/h1&gt;&lt;p&gt; #&lt;br&gt; location ~ .php$ {&lt;br&gt;   root          html;&lt;br&gt;   fastcgi_pass   127.0.0.1:9000;&lt;br&gt;   fastcgi_index  index.php;&lt;br&gt;   fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;&lt;br&gt;   include       fastcgi_params;&lt;br&gt; }&lt;/p&gt;
&lt;p&gt;#取消FastCGI server部分location的注释,并要注意fastcgi_param行的参数,改为$document_root$fastcgi_script_name,或者使用绝对路径&lt;/p&gt;
&lt;p&gt;二、配置php&lt;/p&gt;
&lt;p&gt;vi /etc/php.ini   #编辑&lt;/p&gt;
&lt;p&gt;date.timezone= PRC     #在946行 把前面的分号去掉，改为date.timezone = PRC&lt;/p&gt;
&lt;p&gt;disable_functions=passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec&lt;/p&gt;
&lt;p&gt;,proc_open,proc_get_status,ini_alter,ini_restore,dl,openlog,syslog,readlink&lt;/p&gt;
&lt;p&gt;,symlink,popepassthru,stream_socket_server,escapeshellcmd,dll,popen&lt;/p&gt;
&lt;p&gt;,disk_free_space,checkdnsrr,getservbyname,getservbyport,disk_total_space&lt;/p&gt;
&lt;p&gt;,posix_ctermid,posix_get_last_error,posix_getcwd,posix_getegid,posix_geteuid,posix_getgid&lt;/p&gt;
&lt;p&gt;,posix_getgrgid,posix_getgrnam,posix_getgroups,posix_getlogin,posix_getpgid,posix_getpgrp&lt;/p&gt;
&lt;p&gt;,posix_getpid,posix_getppid,posix_getpwnam,posix_getpwuid,posix_getrlimit,posix_getsid&lt;/p&gt;
&lt;p&gt;,posix_getuid,posix_isatty,posix_kill,posix_mkfifo,posix_setegid,posix_seteuid,posix_setgid&lt;/p&gt;
&lt;p&gt;,posix_setpgid,posix_setsid,posix_setuid,posix_strerror,posix_times,posix_ttyname,posix_uname&lt;/p&gt;
&lt;p&gt;#在386行 列出PHP可以禁用的函数，如果某些程序需要用到这个函数，可以删除，取消禁用。&lt;br&gt;expose_php = Off        #在432行 禁止显示php版本的信息&lt;br&gt;magic_quotes_gpc = On   #在745行 打开magic_quotes_gpc来防止SQL注入&lt;br&gt;open_basedir = .:/tmp/  #在380行，设置表示允许访问当前目录(即PHP脚本文件所在之目录)和/tmp/目录,可以防止php木马跨站，如果改了之后安装程序有问题，可注销此行，或者直接写上程序目录路径/var/www/html/www.osyunwei.com/:/tmp/&lt;/p&gt;
&lt;p&gt;:wq! #保存退出&lt;/p&gt;
&lt;p&gt;(转载者语:magic_quotes_gpc我的配置中是不存在的,open_basedir没有看懂也就跳过了,这两条并没有影响我配置成功,隐患…暂时还没找到或者还没理解)&lt;/p&gt;
&lt;p&gt;三、配置php-fpm&lt;br&gt;cp /etc/php-fpm.d/www.conf   /etc/php-fpm.d/www.confbak   #备份原有配置文件&lt;br&gt;vi /etc/php-fpm.d/www.conf   #编辑&lt;br&gt;user = nginx   #修改用户为nginx&lt;br&gt;group = nginx   #修改组为nginx&lt;/p&gt;
&lt;p&gt;/etc/init.d/mysqld restart  #重启MySql&lt;br&gt;/etc/init.d/nginx  restart  #重启nginx&lt;br&gt;/etc/rc.d/init.d/php-fpm  restart  #重启php-fpm&lt;/p&gt;
&lt;p&gt;#############################################################################&lt;br&gt;测试篇&lt;br&gt;cd /usr/share/nginx/html/   #进入nginx默认网站根目录&lt;br&gt;vi  index.php   #新建index.php文件&lt;/p&gt;
&lt;p&gt;&amp;lt;?php&lt;br&gt;     phpinfo();&lt;/p&gt;
&lt;p&gt;?&amp;gt;&lt;/p&gt;
&lt;p&gt;:wq! #保存&lt;/p&gt;
&lt;p&gt;chown nginx.nginx /usr/share/nginx/html/ -R  #设置目录所有者&lt;/p&gt;
&lt;p&gt;chmod 700  /usr/share/nginx/html/ -R   #设置目录权限&lt;/p&gt;
&lt;p&gt;在客户端浏览器输入服务器IP地址，可以看到相关的配置信息！&lt;/p&gt;
&lt;p&gt;#############################################################################&lt;/p&gt;
&lt;p&gt;备注&lt;/p&gt;
&lt;p&gt;nginx默认站点目录是：/usr/share/nginx/html/&lt;/p&gt;
&lt;p&gt;权限设置：chown nginx.nginx/usr/share/nginx/html/ -R&lt;/p&gt;
&lt;p&gt;MySQL数据库目录是：/var/lib/mysql&lt;/p&gt;
&lt;p&gt;权限设置：chown mysql.mysql -R /var/lib/mysql&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;===================&lt;br&gt;准备篇：&lt;/p&gt;
&lt;p&gt;1、配置防火墙，开启80端口、3306端口&lt;br&gt;vi /etc/sysconfig/iptables&lt;br&gt;-A INPUT -m state –state NEW -m tcp -p tcp –dpo
    
    </summary>
    
    
      <category term="lnmp" scheme="http://xwzmsdqbjzyyg.github.io/tags/lnmp/"/>
    
  </entry>
  
  <entry>
    <title>thinkphp 单字母函数</title>
    <link href="http://xwzmsdqbjzyyg.github.io/2016/05/25/thinkphp-01/"/>
    <id>http://xwzmsdqbjzyyg.github.io/2016/05/25/thinkphp-01/</id>
    <published>2016-05-25T09:00:58.000Z</published>
    <updated>2016-05-25T09:05:47.868Z</updated>
    
    <content type="html">&lt;p&gt;在ThinkPHP中有许多使用简便的单字母函数（即快捷方法），可以很方便开发者快速的调用，但是字母函数却不方便记忆，本文将所有的字母函数总结一下，以方便以后查找。&lt;/p&gt;
&lt;p&gt;1.U() URL组装 支持不同URL模式&lt;br&gt;U($url=’’,$vars=’’,$suffix=true,$domain=false)&lt;/p&gt;
&lt;p&gt;  @param string $url URL表达式，格式：’[模块/控制器/操作#锚点@域名]?参数1=值1&amp;amp;参数2=值2…’&lt;br&gt;  @param string|array $vars 传入的参数，支持数组和字符串&lt;br&gt;  @param string $suffix 伪静态后缀，默认为true表示获取配置值&lt;br&gt;  @param boolean $domain 是否显示域名&lt;br&gt;  @return string&lt;/p&gt;
&lt;p&gt;2.D() D函数用于实例化模型类 格式 [资源://][模块/]模型&lt;br&gt;D($name=’’,$layer=’’)&lt;/p&gt;
&lt;p&gt;  @param string $name 资源地址&lt;br&gt;  @param string $layer 模型层名称&lt;br&gt;  @return Model&lt;/p&gt;
&lt;p&gt;3.M() M函数用于实例化一个没有模型文件的Model&lt;br&gt;M($name=’’,$tablePrefix=’’,$connection=’’)&lt;br&gt;  @param string $name Model名称 支持指定基础模型 例如MongoModel:User&lt;br&gt;  @param string $tablePrefix 表前缀&lt;br&gt;  @param mixed $connection 数据库连接信息&lt;br&gt;  @return Model&lt;/p&gt;
&lt;p&gt;4.I() 获取输入参数 支持过滤和默认值&lt;br&gt;I($name,$default=’’,$filter=null)&lt;br&gt;  使用方法:&lt;/p&gt;
&lt;p&gt;I(‘id’,0); //获取id参数 自动判断get或者post&lt;br&gt;I(‘post.name’,’’,’htmlspecialchars’); //获取$_POST[‘name’]&lt;br&gt;I(‘get.’); //获取$_GET&lt;/p&gt;
&lt;p&gt;5.B() 执行某个行为&lt;br&gt;B($name,$tag=’’,&amp;amp;$params=NULL)&lt;br&gt;  @param string $name 行为名称&lt;br&gt;  @param string $tag 标签名称（行为类无需传入）&lt;br&gt;  @param Mixed $params 传入的参数&lt;br&gt;  @return void&lt;/p&gt;
&lt;p&gt;6.C() 读取及设置配置参数&lt;br&gt;C($name=null,$value=null,$default=null)&lt;/p&gt;
&lt;p&gt;  @param string|array $name 配置变量&lt;br&gt;  @param mixed $value 配置值&lt;br&gt;  @param mixed $default 默认值&lt;br&gt;  @return mixed&lt;/p&gt;
&lt;p&gt;7.E() 抛出异常处理&lt;br&gt;E($msg, $code=0)&lt;/p&gt;
&lt;p&gt;  @param string $msg 异常消息&lt;br&gt;  @param integer $code 异常代码 默认为0&lt;br&gt;  @return void&lt;/p&gt;
&lt;p&gt;8.G() 记录和统计时间（微秒）和内存使用情况&lt;br&gt;G($start,$end=’’,$dec=4)&lt;/p&gt;
&lt;p&gt;  使用方法:&lt;br&gt;G(‘begin’); // 记录开始标记位&lt;br&gt;// … 区间运行代码&lt;br&gt;G(‘end’); // 记录结束标签位&lt;br&gt;echo G(‘begin’,’end’,6); //统计区间运行时间 精确到小数后6位&lt;br&gt;echo G(‘begin’,’end’,’m’); // 统计区间内存使用情况&lt;/p&gt;
&lt;p&gt;  如果end标记位没有定义，则会自动以当前作为标记位&lt;br&gt;  其中统计内存使用需要 MEMORY_LIMIT_ON 常量为true才有效&lt;br&gt;  @param string $start 开始标签&lt;br&gt;  @param string $end 结束标签&lt;br&gt;  @param integer|string $dec 小数位或者m&lt;br&gt;  @return mixed&lt;/p&gt;
&lt;p&gt;9.L()获取和设置语言定义(不区分大小写)&lt;br&gt;L($name=null,$value=null)&lt;/p&gt;
&lt;p&gt;  @param string|array $name 语言变量&lt;br&gt;  @param mixed $value 语言值或者变量&lt;br&gt;  @return mixed&lt;/p&gt;
&lt;p&gt;10.T()获取模版文件 格式 资源://模块@主题/控制器/操作&lt;br&gt;T($template=’’,$layer=’’)&lt;/p&gt;
&lt;p&gt;  @param string $name 模版资源地址&lt;br&gt;  @param string $layer 视图层（目录）名称&lt;br&gt;  @return string&lt;/p&gt;
&lt;p&gt;11.N() 设置和获取统计数据&lt;br&gt;N($key,$step=0,$save=false)&lt;/p&gt;
&lt;p&gt;  使用方法:&lt;br&gt;N(‘db’,1); // 记录数据库操作次数&lt;br&gt;N(‘read’,1); // 记录读取次数&lt;br&gt;echo N(‘db’); // 获取当前页面数据库的所有操作次数&lt;br&gt;echo N(‘read’); // 获取当前页面读取次数&lt;/p&gt;
&lt;p&gt;  @param string $key 标识位置&lt;br&gt;  @param integer $step 步进值&lt;br&gt;  @return mixed&lt;/p&gt;
&lt;p&gt;12.A()A函数用于实例化控制器&lt;/p&gt;
&lt;p&gt;格式：[资源://][模块/]控制器&lt;br&gt;A($name,$layer=’’,$level=’’)&lt;/p&gt;
&lt;p&gt;  @param string $name 资源地址&lt;br&gt;  @param string $layer 控制层名称&lt;br&gt;  @param integer $level 控制器层次&lt;br&gt;  @return Controller|false&lt;/p&gt;
&lt;p&gt;13.R() 远程调用控制器的操作方法&lt;/p&gt;
&lt;p&gt;URL 参数格式 [资源://][模块/]控制器/操作&lt;br&gt;R($url,$vars=array(),$layer=’’)&lt;/p&gt;
&lt;p&gt;  @param string $url 调用地址&lt;br&gt;  @param string|array $vars 调用参数 支持字符串和数组&lt;br&gt;  @param string $layer 要调用的控制层名称&lt;br&gt;  @return mixed&lt;/p&gt;
&lt;p&gt;14.W()渲染输出Widget&lt;br&gt;W($name,$data=array())&lt;/p&gt;
&lt;p&gt;  @param string $name Widget名称&lt;br&gt;  @param array $data 传入的参数&lt;br&gt;  @return void&lt;/p&gt;
&lt;p&gt;15.S()缓存管理&lt;br&gt;S($name,$value=’’,$options=null)&lt;/p&gt;
&lt;p&gt;  @param mixed $name 缓存名称，如果为数组表示进行缓存设置&lt;br&gt;  @param mixed $value 缓存值&lt;br&gt;  @param mixed $options 缓存参数&lt;br&gt;  @return mixed&lt;/p&gt;
&lt;p&gt;16.F() 快速文件数据读取和保存 针对简单类型数据 字符串、数组&lt;br&gt;F($name, $value=’’,$path=DATA_PATH)&lt;/p&gt;
&lt;p&gt;  @param string $name 缓存名称&lt;br&gt;  @param mixed $value 缓存值&lt;br&gt;  @param string $path 缓存路径&lt;br&gt;  @return mixed&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在ThinkPHP中有许多使用简便的单字母函数（即快捷方法），可以很方便开发者快速的调用，但是字母函数却不方便记忆，本文将所有的字母函数总结一下，以方便以后查找。&lt;/p&gt;
&lt;p&gt;1.U() URL组装 支持不同URL模式&lt;br&gt;U($url=’’,$vars=’’,$suf
    
    </summary>
    
    
      <category term="thinkphp" scheme="http://xwzmsdqbjzyyg.github.io/tags/thinkphp/"/>
    
  </entry>
  
  <entry>
    <title>摘抄自知乎的redis相关</title>
    <link href="http://xwzmsdqbjzyyg.github.io/2016/05/24/redis-01/"/>
    <id>http://xwzmsdqbjzyyg.github.io/2016/05/24/redis-01/</id>
    <published>2016-05-24T03:10:00.000Z</published>
    <updated>2016-05-24T03:32:44.122Z</updated>
    
    <content type="html">&lt;p&gt;  1.知乎日报的基础数据和统计信息是用 Redis 存储的，这使得请求的平均响应时间能在 10ms 以下。&lt;br&gt;其他数据仍然需要存放在另外的地方，其实完全用 Redis 也是可行的，主要的考量是内存占用。&lt;br&gt;就使用经验而言，Redis 的数据结构很丰富，精心设计地话，能满足很多应用场景。至少很多时候比 MySQL 更方便&lt;br&gt;2.单独使用Redis的话，它是成当不起数据库的任务，比如你每日活跃用户是1万人，但是你那台redis里面已经积累了50万人了（这个比例很正常），那么每次redis启动，就需要把50万load内存，每次redis备份，又需要把50万dump到磁盘，这靠谱么？&lt;br&gt;把冷数据落地到mongo，热数据在用redis存储。 &lt;/p&gt;
&lt;p&gt;3.redis是目前公认的速度最快的基于内存的键值对数据库，但redis的缺点也非常明显，仅提供最基本的hash set, list, sorted set等基于数据类型，不分表，没有schema，没有索引，没有外键，缺少int/date等基本数据类型，多条件查询需要通过集合内联(sinter,zinterstore)和连接间接实现，操作不便，开发效率低，可维护性不佳； 因此一般不将其视为完整的数据库单独使用，很多网站将redis作为高速缓存和session状态存储层，然后再与其他数据库搭配使用。&lt;/p&gt;
&lt;p&gt;4.核心业务建议数据还是落地到mysql，redis在异常情况下回丢数据。&lt;br&gt;非核心业务，比如运营推广，数据聚合统计这种允许数据少量丢失的业务可以全用mysql，扩展方便，效率高，业务量也不大。特别是运营推广这种时效性很强的业务，在推广结束后数据接没用了，Redis内存压力也不会很大。&lt;br&gt;mysql能支持对各个字段的查询，Redis的查询仅限于对key的简单匹配，如果要对value进行复杂查询，不适合用Redis。&lt;/p&gt;
&lt;p&gt;5.目前redis做数据库还不太靠谱。它支持的数据类型太少，而且查询功能太弱。redis并不是为了作为数据库使用的，它更多地是一个高速存取器，一般用作缓存和类似场景。&lt;/p&gt;
&lt;p&gt;6.redis是一种k/v的内存数据库，适合小数据量的存储以及实时要求高的地方，但是不适合做完整数据库，完整数据库基本上都有一套详细解决方案，比如mysql。&lt;br&gt;我们项目里用到的redis是用来做缓存的，设置过期时间，到时就自动清掉。数据库还是用mysql等这种成熟的方案。&lt;br&gt;如果你非要用一种nosql来做数据库，推荐你用Mongodb&lt;/p&gt;
&lt;p&gt; 7.redis能否做数据库用取决于如下几个条件：&lt;br&gt;1：数据量，毕竟内存数据库，还是受限于内存的容量，虽然可以redis可以持久化。&lt;br&gt;2：数据的结构，是否能够将关系型数据结构都转换为key/value的形式。&lt;br&gt;3：查询的效率，对范围查询等，是否能转换为高效的hash索引查询&lt;/p&gt;
&lt;p&gt;8.MongoDB不是内存型数据库，他只不过把所有文件索引存到内存里而已。同样的机型，用MongoDB会比Redis存更多，但Redis响应更快。关键的是看量有多大。&lt;/p&gt;
&lt;p&gt;9.MongoDB是nosql数据库，它支持把一部分热数据放到内存中，方便用户更快的去处理它。&lt;/p&gt;
&lt;p&gt;Redis是内存型数据库，是完全的内存数据库！所有的数据都在内存，不存在硬盘一部分，内存一部分的情况。当然可以用save去存数据到硬盘，但这是为了备份安全性考虑而不是使用。&lt;/p&gt;
&lt;p&gt; 10.一个哈希实际上是一组键值对的集合，哈希本身的键是“父键”，哈希中包含的若干字段是“子键”，每个“子键”都有相应的值。“子键”之间并没有一定的联系，但是它们共同组成了一个完整的哈希结构。我们可以把一个哈希看做关系数据库中的一行，哈希的每个子键对应行的一个字段。因此，当把关系数据库中的数据缓存至Redis时，使用哈希结构可能会带来方便。需要注意的是，哈希结构内部的子键之间是没有顺序关系的。&lt;/p&gt;
&lt;p&gt;11.Redis是一种内存数据库，这使其在数据存取效率方面表现突出。由于内存中的数据时刻面临丢失的危险，Redis提供了两种持久化机制，及时将内存中的数据写入硬盘。第一种机制为RDB，利用存储快照的方式把内存数据定期写入硬盘；第二种机制为AOF，利用写日志的方式，每执行一条更改Redis数据的命令，就在日志里附加上该命令并保存在硬盘上。Redis默认开启RDB模式，关闭AOF模式，这是因为AOF更加耗时。但是，如果对数据安全要求极高，无法承担任何数据丢失的后果，AOF模式就变成了持久化的首选。&lt;br&gt; 当然，即使Redis具备持久化机制，但是一旦本地硬盘损坏，数据丢失依然在所难免。所以，Redis又提供了复制功能，作用是将一个主数据库（master）的数据自动同步到多个从数据库（slave），从而尽可能防止数据丢失。Redis主从机制可以简单描述为：从数据库启动后，先向主数据库发送SYNC命令；主数据库接到SYNC命令后就开始保存快照，在此期间，所有发给主数据库的命令都被缓存起来；快照保存完成后，主数据库把快照和缓存的命令一起发给从数据库；从数据库保存主数据库发来的快照文件，并依次执行主数据库发来的缓存命令。在同步过程中，从数据库不会阻塞，它默认使用同步之前的数据继续响应客户端发来的命令。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;  1.知乎日报的基础数据和统计信息是用 Redis 存储的，这使得请求的平均响应时间能在 10ms 以下。&lt;br&gt;其他数据仍然需要存放在另外的地方，其实完全用 Redis 也是可行的，主要的考量是内存占用。&lt;br&gt;就使用经验而言，Redis 的数据结构很丰富，精心设计地话
    
    </summary>
    
    
      <category term="redis" scheme="http://xwzmsdqbjzyyg.github.io/tags/redis/"/>
    
  </entry>
  
</feed>
